<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
2    <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: ws: wss: https: 'unsafe-inline'; connect-src 'self' ws: wss: https: data: blob:;">
    <title> ??? </title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="favicon.ico">
    
    <!-- Fixed Size Canvas Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            display: block;
            width: 800px;  /* Tamanho fixo para todos os dispositivos */
            height: 600px; /* Tamanho fixo para todos os dispositivos */
            background: #000;
            border: 2px solid #333;
            image-rendering: pixelated; /* Para manter sprites nítidos */
        }
        
        /* Responsivo para centralizar em telas pequenas */
        @media (max-width: 800px), (max-height: 600px) {
            body {
                padding: 0;
                margin: 0;
                overflow: hidden; /* Evitar scroll */
            }
            
            #gameCanvas {
                /* Manter tamanho fixo mas centralizar */
                display: block;
                margin: 0 auto;
                border: 1px solid #333; /* Borda menor para mobile */
            }
        }
        
        .debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 12px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
            display: none;
        }
        
        /* ===== VIRTUAL JOYSTICK STYLES ===== */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none; /* Oculto por padrão, mostrado apenas em mobile */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .config-section::before {
            content: '►';
            position: absolute;
            left: -15px;
            top: 15px;
            color: #00ff00;
            font-size: 16px;
        }
        
        .config-label {
            display: block;
            font-size: 16px;
            color: #00ff00;
            margin-bottom: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .config-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #00ffff;
            border-radius: 0;
            background: rgba(0, 20, 40, 0.8);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            transition: all 0.3s ease;
            clip-path: polygon(0 0, calc(100% - 10px) 0, 100% 10px, 100% 100%, 0 100%);
            position: relative;
            z-index: 1000;
            pointer-events: auto;
        }
        
        .config-input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 
                0 0 10px #00ff00,
                inset 0 0 10px rgba(0, 255, 0, 0.1);
            background: rgba(0, 30, 60, 0.9);
        }
        
        .config-input::placeholder {
            color: rgba(0, 255, 255, 0.5);
            font-style: italic;
        }
        
        /* Y2K Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
            background: rgba(0, 30, 60, 0.3);
            padding: 10px;
            border: 1px solid #00ffff;
        }
        
        .toggle-label {
            font-size: 16px;
            color: #00ff00;
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .toggle-switch {
            position: relative;
            width: 80px;
            height: 30px;
            appearance: none;
            background: linear-gradient(45deg, #001122, #002244);
            border: 2px solid #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            clip-path: polygon(5px 0, 100% 0, 100% calc(100% - 5px), calc(100% - 5px) 100%, 0 100%, 0 5px);
        }
        
        .toggle-switch:checked {
            background: linear-gradient(45deg, #002200, #004400);
            border-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }
        
        .toggle-switch::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            transition: all 0.3s ease;
            clip-path: polygon(0 0, calc(100% - 3px) 0, 100% 3px, 100% 100%, 3px 100%, 0 calc(100% - 3px));
        }
        
        .toggle-switch:checked::before {
            transform: translateX(48px);
            background: linear-gradient(45deg, #00ff00, #88ff00);
        }
        
        .toggle-status {
            font-size: 14px;
            color: #00ffff;
            font-weight: bold;
            min-width: 100px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .start-game-button {
            background: linear-gradient(45deg, #001122, #003366, #001122);
            color: #00ffff;
            padding: 18px 40px;
            border: 3px solid #00ffff;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            position: relative;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        
        .start-game-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .start-game-button:hover {
            background: linear-gradient(45deg, #003366, #0066cc, #003366);
            border-color: #00ff00;
            box-shadow: 
                0 0 20px #00ff00,
                inset 0 0 20px rgba(0, 255, 0, 0.1);
            transform: translateY(-2px);
            text-shadow: 0 0 10px #00ffff;
        }
        
        .start-game-button:hover::before {
            opacity: 1;
        }
        
        .config-description {
            font-size: 14px;
            color: #00ff00;
            margin-bottom: 25px;
            line-height: 1.6;
            text-align: center;
            font-style: italic;
            padding: 10px;
            border: 1px dashed #00ffff;
            background: rgba(0, 255, 255, 0.05);
        }
        
        /* ===== RESPONSIVIDADE Y2K SCI-FI ===== */
        
        /* Tablets Portrait */
        @media (max-width: 768px) {
            .game-config-content {
                padding: 30px 20px;
                max-width: 90%;
                margin: 20px;
            }
            
            .game-config-title {
                font-size: 24px;
                letter-spacing: 2px;
            }
            
            .config-input {
                font-size: 14px;
                padding: 10px;
            }
            
            .start-game-button {
                padding: 15px 25px;
                font-size: 16px;
                letter-spacing: 1px;
            }
            
            .toggle-switch {
                width: 70px;
                height: 28px;
            }
            
            .toggle-switch::before {
                width: 20px;
                height: 20px;
                top: 2px;
                left: 2px;
            }
            
            .toggle-switch:checked::before {
                transform: translateX(42px);
            }
        }
        
        /* Mobile Portrait */
        @media (max-width: 480px) {
            .game-config-modal {
                padding: 10px;
                align-items: flex-start;
                padding-top: 50px;
            }
            
            .game-config-content {
                padding: 25px 15px;
                max-width: 95%;
                margin: 10px;
                clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px));
            }
            
            .game-config-content::before {
                clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px));
            }
            
            .game-config-title {
                font-size: 20px;
                letter-spacing: 1px;
                margin-bottom: 15px;
            }
            
            .game-config-title::after {
                content: '◊◊◊◊◊◊◊◊◊◊';
                font-size: 10px;
                margin-top: 8px;
            }
            
            .config-description {
                font-size: 12px;
                padding: 8px;
                margin-bottom: 20px;
            }
            
            .config-section {
                margin: 20px 0;
                padding: 12px;
            }
            
            .config-label {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            .config-input {
                font-size: 14px;
                padding: 10px;
                clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 0 100%);
            }
            
            .toggle-container {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
                padding: 8px;
            }
            
            .toggle-label {
                font-size: 14px;
            }
            
            .toggle-switch {
                width: 60px;
                height: 26px;
                align-self: center;
            }
            
            .toggle-switch::before {
                width: 18px;
                height: 18px;
                top: 2px;
                left: 2px;
            }
            
            .toggle-switch:checked::before {
                transform: translateX(34px);
            }
            
            .toggle-status {
                font-size: 12px;
                text-align: center;
                min-width: auto;
            }
            
            .start-game-button {
                padding: 12px 20px;
                font-size: 14px;
                letter-spacing: 1px;
                margin-top: 20px;
                clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
            }
        }
        
        /* Mobile Landscape */
        @media (max-width: 768px) and (orientation: landscape) {
            .game-config-modal {
                padding: 20px 10px;
                align-items: center;
            }
            
            .game-config-content {
                max-width: 80%;
                padding: 20px;
            }
            
            .game-config-title {
                font-size: 22px;
                margin-bottom: 10px;
            }
            
            .config-description {
                font-size: 12px;
                margin-bottom: 15px;
            }
            
            .config-section {
                margin: 15px 0;
                padding: 10px;
            }
        }
        
        /* Very Small Screens */
        @media (max-width: 320px) {
            .game-config-content {
                padding: 20px 10px;
            }
            
            .game-config-title {
                font-size: 18px;
                letter-spacing: 0.5px;
            }
            
            .config-input {
                font-size: 13px;
                padding: 8px;
            }
            
            .start-game-button {
                padding: 10px 15px;
                font-size: 13px;
            }
        }
        
        /* High DPI Displays */
        @media (-webkit-min-device-pixel-ratio: 2) {
            .game-config-content {
                border-width: 1px;
            }
            
            .config-input {
                border-width: 1px;
            }
            
            .toggle-switch {
                border-width: 1px;
            }
        }
        
        /* ===== VIRTUAL JOYSTICK STYLES ===== */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none; /* Oculto por padrão - controlado via JavaScript */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(27, 86, 128, 0.4);
            border: 3px solid rgb(17, 76, 122);
            position: relative;
            box-shadow: 
                0 0 20px rgba(8, 34, 76, 0.6),
                inset 0 0 20px rgba(26, 66, 107, 0.3);
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            
            /* Indicador central sutil */
            &::before {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: rgba(26, 66, 107, 0.6);
                transform: translate(-50%, -50%);
            }
        }
        
        .joystick-base:active {
            transform: scale(1.05);
            border-color: rgb(26, 66, 107);
            box-shadow: 
                0 0 30px rgba(27, 86, 128, 0.5),
                inset 0 0 20px rgba(26, 66, 107, 0.4);
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #1b5680, #0B2B57);
            border: 2px solid rgb(17, 76, 122);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 15px rgb(8, 34, 76), inset 0 2px 5px rgb(26, 66, 107);
            transition: all 0.1s ease;
            cursor: pointer;
            
            /* Highlight central */
            &::before {
                content: '';
                position: absolute;
                top: 20%;
                left: 30%;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.6);
                filter: blur(1px);
            }
        }
        
        .joystick-knob:active {
            background: radial-gradient(circle at 30% 30%, #26608B, #1b5680);
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        /* Responsive para diferentes tamanhos de tela mobile */
        @media (max-width: 480px) {
            .virtual-joystick {
                bottom: 20px;
                left: 20px;
            }
            
            .joystick-base {
                width: 100px;
                height: 100px;
            }
            
            .joystick-knob {
                width: 40px;
                height: 40px;
            }
        }
        
        @media (max-height: 600px) {
            .virtual-joystick {
                bottom: 15px;
                left: 15px;
            }
            
            .joystick-base {
                width: 90px;
                height: 90px;
            }
            
            .joystick-knob {
                width: 35px;
                height: 35px;
            }
        }
        
        /* Orientação landscape em mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .virtual-joystick {
                bottom: 10px;
                left: 15px;
                transform: scale(0.8);
            }
        }
        
        /* Dispositivos com notch */
        @supports (padding: max(0px)) {
            .virtual-joystick {
                bottom: max(30px, env(safe-area-inset-bottom));
                left: max(30px, env(safe-area-inset-left));
            }
        }
    </style>
</head>
<body>
    <!-- Fullscreen Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Mobile Virtual Joystick -->
    <div class="virtual-joystick" id="virtualJoystick">
        <div class="joystick-base" id="joystickBase">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>
    
    <!-- Audio Status Indicator -->
    <div id="audioIndicator" style="
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ffff;
        padding: 10px 15px;
        border-radius: 5px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        z-index: 2000;
        border: 1px solid #00ffff;
        display: none;
    ">
        🎵 Clique para ativar áudio
    </div>
    
    <!-- Debug Info (Hidden by default) -->
    <div class="debug-info" id="debugInfo">
        Debug Mode: ON
    </div>

  <!-- Game Scripts -->
<script src="socket.io.min.js?v=1.0.0"></script>
<script>
  // Debug: Verificar se Socket.io foi carregado
  console.log('🔍 Socket.io disponível:', typeof io !== 'undefined' ? '✅ SIM' : '❌ NÃO');
  if (typeof io !== 'undefined') {
    console.log('📦 Socket.io version:', io.version || 'unknown');
  }
</script>
<script src="config/serverConfig.js"></script>
<script src="legacy/areaManager.js"></script>
<script src="input/inputManager.js"></script>
<script src="sprites/frameBasedSpriteManager.js"></script>
<script src="legacy/frameBasedPlayer.js"></script>
<script src="network/mockServer.js"></script>
<script>
  // Debug: Verificar se MockServer foi carregado
  console.log('🤖 MockServer disponível:', typeof MockServer !== 'undefined' ? '✅ SIM' : '❌ NÃO');
</script>
<script src="network/networkManager.js"></script>
<script src="network/multiplayerManager.js"></script>

<!-- Component System -->
<script src="managers/AssetLoader.js"></script>
<script src="managers/SceneManager.js"></script>
<script src="managers/CollisionManager.js"></script>
<script src="managers/InteractionManager.js"></script>
<script src="components/GameCore.js"></script>

<script src="core/gameClient.js"></script>

    <script>
        // ===== SISTEMA DE PERMISSÃO DE ÁUDIO =====
        let audioEnabled = false;
        
        // Sistema de áudio global e simples
        window.audioManager = {
            audioCache: new Map(),
            currentBackgroundMusic: null,
            isBackgroundPlaying: false,
            
            preloadAudio(src) {
                if (!this.audioCache.has(src)) {
                    const audio = new Audio(src);
                    audio.preload = 'auto';
                    audio.volume = 0.5;
                    audio.load();
                    this.audioCache.set(src, audio);
                    console.log('🎵 Áudio pré-carregado:', src);
                }
                return this.audioCache.get(src);
            },
            
            startBackgroundMusic(src = 'songs/backgroundsond.mp3', volume = 0.3) {
                if (!audioEnabled) {
                    console.log('🔇 Áudio não habilitado - música de fundo não iniciada');
                    return;
                }
                
                try {
                    this.stopBackgroundMusic();
                    const audio = this.preloadAudio(src);
                    audio.loop = true;
                    audio.volume = volume;
                    
                    audio.play().then(() => {
                        this.currentBackgroundMusic = audio;
                        this.isBackgroundPlaying = true;
                        console.log('🎵 Música de fundo iniciada:', src);
                    }).catch(error => {
                        console.warn('⚠️ Erro ao tocar música de fundo:', error);
                    });
                } catch (error) {
                    console.error('❌ Erro no sistema de áudio:', error);
                }
            },
            
            stopBackgroundMusic() {
                if (this.currentBackgroundMusic) {
                    this.currentBackgroundMusic.pause();
                    this.currentBackgroundMusic.currentTime = 0;
                    this.currentBackgroundMusic = null;
                    this.isBackgroundPlaying = false;
                }
            },
            
            playAudioFast(src = 'songs/tp_song.mp3') {
                if (!audioEnabled) {
                    console.log('🔇 Áudio não habilitado - efeito sonoro não reproduzido');
                    return;
                }
                
                try {
                    const audio = this.preloadAudio(src);
                    audio.currentTime = 0;
                    audio.play().then(() => {
                        console.log('🎵 Efeito sonoro reproduzido:', src);
                    }).catch(e => {
                        console.warn('⚠️ Erro ao reproduzir efeito sonoro:', e);
                    });
                } catch (error) {
                    console.error('❌ Erro ao reproduzir áudio:', error);
                }
            },
            
            playAudio(src = 'songs/tp_song.mp3') {
                this.playAudioFast(src);
            }
        };
        
        // ===== VIRTUAL JOYSTICK CLASS =====
        class VirtualJoystick {
            constructor() {
                this.joystickElement = document.getElementById('virtualJoystick');
                this.baseElement = document.getElementById('joystickBase');
                this.knobElement = document.getElementById('joystickKnob');
                
                this.isActive = false;
                this.startPos = { x: 0, y: 0 };
                this.currentPos = { x: 0, y: 0 };
                this.direction = { x: 0, y: 0 }; // Valores normalizados entre -1 e 1
                this.magnitude = 0; // Intensidade do movimento (0 a 1)
                
                this.baseRadius = 60; // Raio da base do joystick
                this.knobRadius = 25; // Raio do knob
                this.maxDistance = this.baseRadius - this.knobRadius; // Distância máxima do knob do centro
                
                this.onMoveCallback = null;
                this.onStartCallback = null;
                this.onEndCallback = null;
                
                this.setupEvents();
                this.detectMobileDevice();
                
                console.log('🕹️ VirtualJoystick inicializado');
            }
            
            detectMobileDevice() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                                 'ontouchstart' in window ||
                                 navigator.maxTouchPoints > 0;
                
                // DEBUG: Forçar exibição para testar
                const forceShow = true;
                
                if (isMobile || forceShow) {
                    this.joystickElement.style.display = 'block';
                    this.joystickElement.style.pointerEvents = 'auto';
                    console.log('📱 Joystick virtual habilitado (mobile:', isMobile, 'force:', forceShow, ')');
                } else {
                    this.joystickElement.style.display = 'none';
                    console.log('🖥️ Dispositivo desktop detectado - joystick virtual desabilitado');
                }
                
                return isMobile || forceShow;
            }
            
            setupEvents() {
                // Sistema simples e direto - sem flags complexas
                this.baseElement.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.startInput(e);
                });
                
                this.baseElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startInput(e);
                }, { passive: false });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isActive) this.moveInput(e);
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (this.isActive) this.moveInput(e);
                }, { passive: false });
                
                document.addEventListener('mouseup', (e) => {
                    if (this.isActive) this.endInput(e);
                });
                
                document.addEventListener('touchend', (e) => {
                    if (this.isActive) this.endInput(e);
                }, { passive: false });
                
                // Prevenir comportamentos padrão
                this.baseElement.addEventListener('dragstart', (e) => e.preventDefault());
                this.baseElement.addEventListener('selectstart', (e) => e.preventDefault());
                this.baseElement.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            startInput(event) {
                if (this.isActive) {
                    console.log('❌ Tentativa de ativação dupla ignorada');
                    return;
                }
                
                console.log('🟢 Iniciando joystick...');
                this.isActive = true;
                const touch = event.touches ? event.touches[0] : event;
                const rect = this.baseElement.getBoundingClientRect();
                
                this.startPos = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                
                this.currentPos = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                
                this.updateKnobPosition();
                console.log('🕹️ Joystick ATIVADO - magnitude:', this.magnitude.toFixed(2), 'direction:', this.direction);
            }
            
            moveInput(event) {
                if (!this.isActive) {
                    console.log('❌ Movimento ignorado - joystick inativo');
                    return;
                }
                
                const touch = event.touches ? event.touches[0] : event;
                
                this.currentPos = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                
                this.updateKnobPosition();
                
                if (this.magnitude > 0.1) {
                    console.log('🕹️ MOVIMENTO - magnitude:', this.magnitude.toFixed(2), 'direction:', 
                        { x: this.direction.x.toFixed(2), y: this.direction.y.toFixed(2) });
                }
            }
            
            endInput(event) {
                if (!this.isActive) {
                    console.log('❌ Tentativa de desativação ignorada - já inativo');
                    return;
                }
                
                console.log('🔴 Desativando joystick...');
                this.isActive = false;
                this.direction = { x: 0, y: 0 };
                this.magnitude = 0;
                this.knobElement.style.transform = 'translate(-50%, -50%)';
                
                console.log('🕹️ Joystick DESATIVADO');
            }
            
            // Método para forçar finalização em casos de emergência
            forceEnd() {
                if (this.isActive) {
                    this.isActive = false;
                    this.isDragging = false;
                    this.eventType = null;
                    
                    // Retornar knob para o centro
                    this.direction = { x: 0, y: 0 };
                    this.magnitude = 0;
                    this.knobElement.style.transform = 'translate(-50%, -50%)';
                    
                    if (this.onEndCallback) {
                        this.onEndCallback(this.direction, this.magnitude);
                    }
                    
                    console.log('🕹️ Joystick forçadamente desativado');
                }
            }
            
            updateKnobPosition() {
                const deltaX = this.currentPos.x - this.startPos.x;
                const deltaY = this.currentPos.y - this.startPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Limitar movimento do knob dentro da base
                const clampedDistance = Math.min(distance, this.maxDistance);
                const angle = Math.atan2(deltaY, deltaX);
                
                const knobX = Math.cos(angle) * clampedDistance;
                const knobY = Math.sin(angle) * clampedDistance;
                
                // Atualizar posição visual do knob
                this.knobElement.style.transform = `translate(-50%, -50%) translate(${knobX}px, ${knobY}px)`;
                
                // Calcular direção normalizada (-1 a 1)
                this.direction = {
                    x: clampedDistance > 0 ? knobX / this.maxDistance : 0,
                    y: clampedDistance > 0 ? knobY / this.maxDistance : 0
                };
                
                // Calcular magnitude (0 a 1)
                this.magnitude = clampedDistance / this.maxDistance;
            }
            
            // Métodos para configurar callbacks
            setOnMove(callback) {
                this.onMoveCallback = callback;
            }
            
            setOnStart(callback) {
                this.onStartCallback = callback;
            }
            
            setOnEnd(callback) {
                this.onEndCallback = callback;
            }
            
            // Getter para verificar se está ativo
            get active() {
                return this.isActive;
            }
            
            // Getter para direção atual
            get currentDirection() {
                return { ...this.direction };
            }
            
            // Getter para magnitude atual
            get currentMagnitude() {
                return this.magnitude;
            }
        }
        
        // ===== SISTEMA DE CONFIGURAÇÃO DO JOGO =====
        let gameConfig = {
            playerName: '',
            audioEnabled: true // Padrão habilitado
        };
        
        // Variável global para controlar se o áudio foi desbloqueado
        window.audioUnlocked = false;
        
        // Função para carregar configurações do localStorage vindas da página de config
        function loadGameConfig() {
            console.log('🔍 Iniciando carregamento de configurações...');
            console.log('🗂️ Verificando localStorage disponível:', typeof(Storage) !== "undefined");
            
            try {
                // Listar todas as chaves do localStorage para debug
                console.log('🗃️ Chaves disponíveis no localStorage:', Object.keys(localStorage));
                
                const storedConfig = localStorage.getItem('gameConfig');
                console.log('📥 localStorage gameConfig (raw):', storedConfig);
                console.log('📥 Tipo do valor obtido:', typeof storedConfig);
                
                if (storedConfig) {
                    console.log('✅ Configuração encontrada no localStorage');
                    
                    const parsedConfig = JSON.parse(storedConfig);
                    console.log('📋 Configuração parseada:', parsedConfig);
                    console.log('🔊 audioEnabled na config:', parsedConfig.audioEnabled, typeof parsedConfig.audioEnabled);
                    console.log('👤 playerName na config:', parsedConfig.playerName, typeof parsedConfig.playerName);
                    
                    // Backup das configurações antes de mesclar
                    const configBackup = { ...gameConfig };
                    console.log('💾 Backup das configurações padrão:', configBackup);
                    
                    gameConfig = { ...gameConfig, ...parsedConfig };
                    console.log('⚙️ Configurações mescladas:', gameConfig);
                    console.log('🔊 gameConfig.audioEnabled final:', gameConfig.audioEnabled, typeof gameConfig.audioEnabled);
                    
                    // Limpar localStorage após carregar
                    localStorage.removeItem('gameConfig');
                    console.log('🗑️ localStorage limpo após carregamento');
                    
                    // Verificar se foi realmente removido
                    const verificacaoRemocao = localStorage.getItem('gameConfig');
                    console.log('🔍 Verificação pós-remoção:', verificacaoRemocao);
                    
                    return true;
                } else {
                    console.log('⚠️ Nenhuma configuração encontrada no localStorage');
                }
            } catch (error) {
                console.error('❌ Erro ao carregar configurações:', error);
                console.error('❌ Stack trace:', error.stack);
            }
            
            console.log('⚙️ Usando configurações padrão');
            return false;
        }
        
        // Verificar se deve redirecionar para página de configuração
        function checkConfigRedirect() {
            // Se não tem configurações salvas, redirecionar para config.html
            const hasConfig = loadGameConfig();
            if (!hasConfig) {
                console.log('🔄 Redirecionando para página de configuração...');
                window.location.href = 'config.html';
                return false;
            }
            return true;
        }
        
        // Aplicar configurações carregadas
        function applyGameConfig() {
            // Verificar se já foi aplicado para evitar loop infinito
            if (window.configAlreadyApplied) {
                console.log('⚠️ Configurações já aplicadas, evitando loop');
                return;
            }
            
            console.log('🚀 Aplicando configurações do jogo:', gameConfig);
            console.log('🔊 Verificando áudio - audioEnabled:', gameConfig.audioEnabled, typeof gameConfig.audioEnabled);
            
            // Marcar como aplicado
            window.configAlreadyApplied = true;
            
            // Configurar áudio se habilitado
            if (gameConfig.audioEnabled === true) {
                console.log('✅ Áudio HABILITADO - chamando enableAudio()');
                enableAudio();
            } else {
                console.log('🔇 Áudio DESABILITADO pelo usuário');
                console.log('🔇 Motivo - gameConfig.audioEnabled =', gameConfig.audioEnabled);
                audioEnabled = false;
            }
            
            // Aplicar nome do jogador se o gameClient já existir
            if (gameClient) {
                gameClient.gameState.nickname = gameConfig.playerName;
                // Também atualizar o player se existir
                if (gameClient.player) {
                    gameClient.player.nickname = gameConfig.playerName;
                }
                console.log(`👤 Nome do jogador definido: ${gameConfig.playerName}`);
            } else {
                // Se gameClient ainda não existe, salvar para aplicar depois
                console.log(`👤 Nome será aplicado quando o jogo inicializar: ${gameConfig.playerName}`);
            }
            
            console.log('✅ Configurações aplicadas com sucesso!');
        }
        
        // Função para habilitar áudio (chamada internamente)
        function enableAudio() {
            console.log('🎵 Habilitando sistema de áudio...');
            audioEnabled = true;
            
            // Mostrar indicador de áudio
            const audioIndicator = document.getElementById('audioIndicator');
            if (audioIndicator) {
                audioIndicator.style.display = 'block';
            }
            
            // Criar função para desbloquear áudio na primeira interação
            const unlockAudio = () => {
                console.log('🎵 Primeira interação detectada - desbloqueando áudio...');
                
                // Esconder indicador
                if (audioIndicator) {
                    audioIndicator.style.display = 'none';
                    console.log('👁️ Indicador de áudio escondido');
                }
                
                // Tocar um som silencioso para desbloquear o contexto de áudio
                console.log('🔇 Criando áudio de teste silencioso...');
                const testAudio = new Audio('songs/backgroundsond.mp3');
                testAudio.volume = 0.01; // Volume muito baixo ao invés de 0
                testAudio.currentTime = 0;
                
                console.log('▶️ Tentando reproduzir áudio de teste...');
                testAudio.play().then(() => {
                    console.log('✅ Contexto de áudio desbloqueado com sucesso!');
                    
                    // Marcar áudio como desbloqueado globalmente
                    window.audioUnlocked = true;
                    audioEnabled = true; // ← Crucial: ativar o audioEnabled também!
                    console.log('🔓 Áudio globalmente desbloqueado - window.audioUnlocked =', window.audioUnlocked);
                    console.log('🔊 audioEnabled definido como:', audioEnabled);
                    
                    // Verificar se audioManager está disponível
                    console.log('🔍 Verificando disponibilidade do audioManager...');
                    if (window.audioManager) {
                        console.log('🎵 AudioManager encontrado - iniciando áudio...');
                        
                        try {
                            // Pré-carregar áudios críticos
                            console.log('📦 Pré-carregando áudios...');
                            window.audioManager.preloadAudio('songs/backgroundsond.mp3');
                            window.audioManager.preloadAudio('songs/tp_song.mp3');
                            
                            // Iniciar música de fundo
                            console.log('🎵 Iniciando música de fundo via AudioManager...');
                            window.audioManager.startBackgroundMusic();
                            
                            // Inicializar áudio da área atual se disponível
                            if (gameClient && gameClient.areaManager) {
                                console.log('🎵 Inicializando áudio da área atual via AreaManager...');
                                gameClient.areaManager.initializeAreaAudio();
                            }
                        } catch (error) {
                            console.error('❌ Erro ao usar AudioManager:', error);
                        }
                    } else {
                        console.log('⚠️ AudioManager não encontrado - aguardando carregamento...');
                        
                        // Aguardar um pouco e tentar novamente
                        setTimeout(() => {
                            if (window.audioManager) {
                                console.log('🎵 AudioManager carregado após timeout - iniciando áudio...');
                                window.audioManager.preloadAudio('songs/backgroundsond.mp3');
                                window.audioManager.preloadAudio('songs/tp_song.mp3');
                                window.audioManager.startBackgroundMusic();
                                
                                if (gameClient && gameClient.areaManager) {
                                    gameClient.areaManager.initializeAreaAudio();
                                }
                            } else {
                                console.log('⚠️ AudioManager ainda não encontrado - tentando método alternativo...');
                                
                                // Método alternativo: criar e tocar áudio diretamente
                                const backgroundMusic = new Audio('songs/backgroundsond.mp3');
                                backgroundMusic.loop = true;
                                backgroundMusic.volume = 0.5;
                                
                                backgroundMusic.play().then(() => {
                                    console.log('✅ Música de fundo iniciada com método alternativo!');
                                }).catch(error => {
                                    console.log('❌ Erro ao tocar música de fundo:', error);
                                });
                            }
                        }, 1000);
                    }
                    
                    // Também tentar inicializar música da área atual se AreaManager já existe
                    if (gameClient && gameClient.areaManager) {
                        console.log('🎵 Tentando inicializar música da área após desbloqueio...');
                        gameClient.areaManager.initializeAreaAudio();
                    }
                    
                    // Remover listeners após desbloqueio
                    document.removeEventListener('click', unlockAudio);
                    document.removeEventListener('keydown', unlockAudio);
                    document.removeEventListener('touchstart', unlockAudio);
                    
                }).catch(e => {
                    console.error('❌ Erro ao desbloquear áudio:', e);
                    console.log('🔄 Tentando método alternativo de desbloqueio...');
                    
                    // Método alternativo: definir flags mesmo com erro
                    window.audioUnlocked = true;
                    audioEnabled = true;
                    console.log('⚡ Flags de áudio definidas mesmo com erro');
                    
                    // Esconder indicador
                    if (audioIndicator) {
                        audioIndicator.style.display = 'none';
                    }
                    
                    // Tentar inicializar AudioManager mesmo assim
                    if (window.audioManager) {
                        console.log('🎵 Tentando AudioManager mesmo com erro...');
                        try {
                            window.audioManager.startBackgroundMusic();
                        } catch (audioError) {
                            console.error('❌ Erro no AudioManager:', audioError);
                        }
                    }
                });
            };
            
            // Aguardar primeira interação do usuário para desbloquear áudio
            document.addEventListener('click', unlockAudio, { once: true });
            document.addEventListener('keydown', unlockAudio, { once: true });
            document.addEventListener('touchstart', unlockAudio, { once: true });
            
            console.log('🎵 Sistema de áudio configurado - aguardando interação do usuário...');
        }
        
        // Inicialização do jogo
        let gameClient = null;

        // Inicializar jogo
        async function initGame() {
            try {
                // Verificar se já foi inicializado
                if (window.gameInitialized) {
                    console.log('⚠️ Jogo já inicializado, evitando duplicação');
                    return;
                }
                
                // Verificar se deve redirecionar para configuração
                if (!checkConfigRedirect()) {
                    return; // Página será redirecionada
                }
                
                // Marcar como inicializado
                window.gameInitialized = true;
                
                // Configurar canvas com tamanho fixo
                setupFixedCanvas();
                
                gameClient = new GameClient();
                await gameClient.init('gameCanvas');  // Inicializar gameClient primeiro
                
                // Aplicar configurações carregadas (APENAS UMA VEZ)
                applyGameConfig();
                
                // Aplicar nome do jogador das configurações se disponível
                if (gameConfig && gameConfig.playerName) {
                    gameClient.gameState.nickname = gameConfig.playerName;
                    console.log(`👤 Nome do jogador aplicado na inicialização: ${gameConfig.playerName}`);
                }
                
                // Inicializar sistema de componentes
                window.gameCore = new GameCore();
                await gameCore.init('gameCanvas');
                
                // Integrar com o sistema legado
                gameCore.integrateWithLegacySystem(gameClient);
                
                // Inicializar sistema de interação com mouse (agora que gameClient.canvas existe)
                gameClient.mouseManager = new MouseInteractionManager(gameClient);
                
                // Inicializar joystick virtual para dispositivos móveis
                gameClient.virtualJoystick = new VirtualJoystick();
                
                // O joystick virtual agora será integrado diretamente no update do player
                // Não precisamos mais de callbacks aqui - o gameClient vai acessar os dados diretamente
                
                // Tornar joystick disponível globalmente para debug
                window.virtualJoystick = gameClient.virtualJoystick;
                
                // Ponto de interação na área "up" - posição fixa no centro
                const interactionWidth = 76.9;  // mantém o mesmo tamanho
                const interactionHeight = 50.5; // mantém o mesmo tamanho
                
                // Coordenadas fixas baseadas no tamanho do canvas (800x600)
                const interactionX = (800 / 2) - (interactionWidth / 2);   // centralizado horizontalmente (400 - 38.45 = 361.55)
                const interactionY = (600 / 2) - (interactionHeight / 2);  // centralizado verticalmente (300 - 25.25 = 274.75)
                
                gameClient.mouseManager.addInteractionPoint(
                    interactionX,        // x
                    interactionY,        // y
                    interactionWidth,    // width
                    interactionHeight,   // height
                    () => {
                        // Função vazia - interação com clique removida
                        // Só funciona através da colisão do player
                    },
                    'area_up_interaction',
                    'up' // NOVA: Especifica que esta interação só funciona na área "up"
                );
                
                // Função helper para facilitar criação de pontos de interação
                window.addInteractionPoint = (x, y, width, height, action, id, requiredArea = null) => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.addInteractionPoint(x, y, width, height, action, id, requiredArea);
                    }
                };
                
                window.removeInteractionPoint = (id) => {
                    if (gameClient && gameClient.mouseManager) {
                        gameClient.mouseManager.removeInteractionPoint(id);
                    }
                };
                
                // Helper para obter posição do mouse facilmente
                window.getMousePos = () => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.currentMousePos;
                    }
                    return { x: -1, y: -1 };
                };
                
                // Inicializar música de fundo da área inicial
                setTimeout(() => {
                    if (gameClient.areaManager) {
                        gameClient.areaManager.initializeAreaAudio();
                    }
                }, 500); // Pequeno delay para garantir que tudo esteja carregado
                
                
                // Canvas tem tamanho fixo - não precisa de redimensionamento
                // window.addEventListener('resize', () => { ... }); // Removido
                
                // Iniciar game loop
                startGameLoop();
                
                console.log('🎮 Blog interativo inicializado com sucesso!');
                
                // ===== CONEXÃO AUTOMÁTICA AO SERVIDOR =====
                console.log('🔗 Iniciando conexão automática...');
                showConnectionStatus('🔄 Conectando ao servidor...', true);
                
                try {
                    await gameClient.connect('Player');
                    console.log('✅ Conectado automaticamente ao servidor multiplayer!');
                    showConnectionStatus('✅ Conectado!', false);
                } catch (error) {
                    console.log('⚠️ Falha na conexão automática, continuando em modo singleplayer:', error.message);
                    showConnectionStatus('⚠️ Modo offline', false);
                    // Não é um erro crítico - o jogo continua funcionando offline
                }
                
        // Configurar canvas com tamanho fixo
        function setupFixedCanvas() {
            const canvas = document.getElementById('gameCanvas');
            
            // Configurar dimensões do canvas sempre fixas (800x600)
            const FIXED_WIDTH = 800;
            const FIXED_HEIGHT = 600;
            
            // Verificar se é dispositivo pequeno/móvel (para joystick e câmera)
            const isSmallScreen = window.innerWidth <= 800 || window.innerHeight <= 600;
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Definir dimensões fixas do canvas
            canvas.width = FIXED_WIDTH;
            canvas.height = FIXED_HEIGHT;
            
            // Controlar visibilidade inicial do joystick virtual
            const virtualJoystick = document.getElementById('virtualJoystick');
            if (virtualJoystick) {
                if (isSmallScreen || isMobile) {
                    virtualJoystick.style.display = 'block';
                } else {
                    virtualJoystick.style.display = 'none';
                }
            }
            
            console.log(`Canvas configurado com tamanho fixo: ${canvas.width}x${canvas.height}`);
            console.log(`Dispositivo móvel/pequeno: ${isSmallScreen || isMobile} (câmera e joystick ativos)`);
            
            // Salvar dimensões como constantes globais para fácil acesso
            window.GAME_WIDTH = FIXED_WIDTH;
            window.GAME_HEIGHT = FIXED_HEIGHT;
            
            // Função para controlar joystick dinamicamente (canvas mantém tamanho fixo)
            function updateJoystickVisibility() {
                // Evitar execução excessiva
                if (updateJoystickVisibility.isExecuting) return;
                updateJoystickVisibility.isExecuting = true;
                
                const isSmallScreen = window.innerWidth <= 800 || window.innerHeight <= 600;
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const shouldShowJoystick = isSmallScreen || isMobile;
                
                // Controlar visibilidade do joystick virtual
                const virtualJoystick = document.getElementById('virtualJoystick');
                if (virtualJoystick) {
                    if (shouldShowJoystick) {
                        virtualJoystick.style.display = 'block';
                    } else {
                        virtualJoystick.style.display = 'none';
                    }
                }
                
                // Atualizar sistema de câmera se existe
                if (window.gameClient && window.gameClient.camera) {
                    window.gameClient.camera.enabled = window.gameClient.shouldEnableCamera();
                }
                
                // Liberar flag após timeout
                setTimeout(() => {
                    updateJoystickVisibility.isExecuting = false;
                }, 100);
            }
            
            // Listener para controlar joystick em mudanças de orientação/tamanho
            window.addEventListener('resize', updateJoystickVisibility);
            window.addEventListener('orientationchange', () => {
                setTimeout(updateJoystickVisibility, 100); // Delay para orientação estabilizar
            });
        }
                
        } catch (error) {
            console.error('❌ Erro ao inicializar:', error);
        }
    }
        
    // ===== FUNÇÕES DE UTILITY =====
    
    // Mostrar status de conexão
    function showConnectionStatus(message, show = true) {
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.style.display = show ? 'block' : 'none';
            
            // Auto-hide depois de 5 segundos se não for um status de loading
            if (show && !message.includes('🔄')) {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 5000);
            }
        }
    }
    
    // Atualizar status de retry
    function updateRetryStatus(attempt, maxAttempts, url, delay = 0) {
        const isRender = url.includes('render.com');
        const serverType = isRender ? 'Render' : 'servidor';
        
        if (delay > 0) {
            showConnectionStatus(`⏳ Aguardando ${Math.round(delay/1000)}s para retry ${attempt}/${maxAttempts} (${serverType})`, true);
        } else {
            showConnectionStatus(`🔄 Tentativa ${attempt}/${maxAttempts} - ${serverType}${isRender ? ' (pode estar em sleep)' : ''}`, true);
        }
    }

    // Game loop
        let lastTime = 0;
        function startGameLoop() {
            function gameLoop(currentTime) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                if (gameClient) {
                    gameClient.update(deltaTime);
                    gameClient.render();
                }

                requestAnimationFrame(gameLoop);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Função para obter coordenadas do mouse em relação a uma div/element
        function getMousePosition(event, element) {
            const rect = element.getBoundingClientRect();
            const scaleX = element.width / rect.width;   // Escala X do canvas
            const scaleY = element.height / rect.height; // Escala Y do canvas
            
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY,
                // Coordenadas brutas (sem escala) caso precise
                rawX: event.clientX - rect.left,
                rawY: event.clientY - rect.top,
                // Informações da div
                elementRect: rect
            };
        }

        // Sistema de pontos de interação via mouse
        class MouseInteractionManager {
            constructor(gameClient) {
                this.gameClient = gameClient;
                this.canvas = gameClient.canvas;
                this.interactionPoints = [];
                this.isMouseDown = false;
                this.currentMousePos = { x: 0, y: 0 };
                
                this.setupMouseEvents();
                console.log('🖱️ MouseInteractionManager inicializado');
            }

            setupMouseEvents() {
                // Rastrear movimento do mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    this.currentMousePos = getMousePosition(e, this.canvas);
                    this.checkInteractions();
                });

                // Clique do mouse
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    const mousePos = getMousePosition(e, this.canvas);
                    this.handleClick(mousePos);
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    this.isMouseDown = false;
                });

                // Deixar área do canvas
                this.canvas.addEventListener('mouseleave', (e) => {
                    this.currentMousePos = { x: -1, y: -1 };
                });
            }

            // Adicionar ponto de interação
            addInteractionPoint(x, y, width, height, action, id = null, requiredArea = null) {
                const point = {
                    id: id || `point_${this.interactionPoints.length}`,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    action: action,
                    isHovered: false,
                    cooldown: 0,
                    requiredArea: requiredArea, // Nova propriedade para especificar área necessária
                    playerInside: false,
                    audioPlayed: false,
                    checkCounter: 0
                };
                
                this.interactionPoints.push(point);
                console.log(`🎯 Ponto de interação adicionado: ${point.id} em (${x}, ${y})${requiredArea ? ` [Área: ${requiredArea}]` : ''}`);
                return point;
            }

            // Remover ponto de interação
            removeInteractionPoint(id) {
                this.interactionPoints = this.interactionPoints.filter(point => point.id !== id);
                console.log(`🗑️ Ponto de interação removido: ${id}`);
            }

            // Verificar se ponto está dentro da área
            isPointInside(mousePos, area) {
                return mousePos.x >= area.x && 
                       mousePos.x <= area.x + area.width &&
                       mousePos.y >= area.y && 
                       mousePos.y <= area.y + area.height;
            }

            // Verificar colisão entre retângulos (player vs área de interação)
            isPlayerColliding(player, area) {
                // Obter dimensões reais do player baseado na animação atual
                let playerWidth = player.width || 32;  // valor padrão se não definido
                let playerHeight = player.height || 32; // valor padrão se não definido
                
                // Tentar obter dimensões do sprite atual se disponível
                if (player.currentSprite && player.currentSprite.width && player.currentSprite.height) {
                    playerWidth = player.currentSprite.width;
                    playerHeight = player.currentSprite.height;
                } else if (player.spriteManager && player.spriteManager.currentSprite) {
                    // Verificar se há informações no sprite manager
                    const currentSprite = player.spriteManager.currentSprite;
                    if (currentSprite.width && currentSprite.height) {
                        playerWidth = currentSprite.width;
                        playerHeight = currentSprite.height;
                    }
                }
                
                // Log das dimensões para debug
                if (playerWidth !== 32 || playerHeight !== 32) {
                    console.log(`🎮 Usando dimensões do sprite: ${playerWidth}x${playerHeight}`);
                }
                
                // Detecção de colisão AABB (Axis-Aligned Bounding Box)
                return player.x < area.x + area.width &&
                       player.x + playerWidth > area.x &&
                       player.y < area.y + area.height &&
                       player.y + playerHeight > area.y;
            }

            // Eventos de hover
            onPointEnter(point) {
                this.canvas.style.cursor = 'pointer';
                console.log(`🎯 Mouse entrou na área: ${point.id}`);
            }

            onPointLeave(point) {
                this.canvas.style.cursor = 'default';
                console.log(`🎯 Mouse saiu da área: ${point.id}`);
            }

            // Manipular clique
            handleClick(mousePos) {
                this.interactionPoints.forEach(point => {
                    if (this.isPointInside(mousePos, point) && point.cooldown === 0) {
                        console.log(`🖱️ Clique em: ${point.id} na posição (${mousePos.x.toFixed(1)}, ${mousePos.y.toFixed(1)})`);
                        
                        // Executar ação
                        if (typeof point.action === 'function') {
                            point.action(mousePos, point);
                        }
                        
                        // Cooldown para evitar spam
                        point.cooldown = 30; // ~0.5 segundos
                    }
                });
            }

            // Renderizar áreas de debug
            renderDebugAreas(ctx) {
                if (!this.gameClient.debug.enabled) return;

                ctx.save();
                
                // Obter área atual
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                this.interactionPoints.forEach(point => {
                    // Só renderizar area_up_interaction quando estiver na área 'up'
                    if (point.id === 'area_up_interaction' && currentArea !== 'up') {
                        return; // Pula a renderização desta interação
                    }
                    
                    // Área de interação
                    ctx.strokeStyle = point.isHovered ? '#00FF00' : '#FF6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(point.x, point.y, point.width, point.height);
                    
                    // Label
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.fillText(point.id, point.x, point.y - 5);
                    
                    // Highlight se estiver hovering
                    if (point.isHovered) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                        ctx.fillRect(point.x, point.y, point.width, point.height);
                    }
                });

                // Mostrar posição atual do mouse
                if (this.currentMousePos.x >= 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(this.currentMousePos.x, this.currentMousePos.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Coordenadas
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '10px Arial';
                    ctx.fillText(`(${this.currentMousePos.x.toFixed(0)}, ${this.currentMousePos.y.toFixed(0)})`, 
                                this.currentMousePos.x + 5, this.currentMousePos.y - 5);
                }
                
                ctx.restore();
            }

            // Atualizar visibilidade das interações baseada na área atual
            updateInteractionsForArea(currentArea) {
                this.interactionPoints.forEach(point => {
                    // Interação area_up_interaction só funciona na área "up"
                    if (point.id === 'area_up_interaction') {
                        point.visible = (currentArea === 'up');
                        if (!point.visible) {
                            point.isHovered = false; // Reset hover se não estiver visível
                        }
                    }
                });
            }

            // Verificar interações - otimizado por área
            checkInteractions() {
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                // Cache do player para evitar múltiplas buscas (só se necessário)
                let playerCached = false;
                
                this.interactionPoints.forEach(point => {
                    // OTIMIZAÇÃO PRINCIPAL: Só processar interações da área atual
                    if (point.requiredArea && point.requiredArea !== currentArea) {
                        // Reset estado se não estiver na área correta
                        if (point.isHovered) point.isHovered = false;
                        if (point.playerInside) {
                            point.playerInside = false;
                            point.audioPlayed = false; // Reset áudio ao sair da área
                        }
                        return; // Skip processamento - ECONOMIA MASSIVA DE CPU
                    }

                    // Verificação de cooldown
                    if (point.cooldown > 0) {
                        point.cooldown--;
                    }

                    // Verificação de mouse (sempre ativa)
                    const wasHovered = point.isHovered;
                    point.isHovered = this.isPointInside(this.currentMousePos, point);

                    // Eventos de mouse
                    if (point.isHovered && !wasHovered) {
                        this.onPointEnter(point);
                    }
                    
                    if (!point.isHovered && wasHovered) {
                        this.onPointLeave(point);
                    }

                    // Verificação de personagem (só para interações específicas e na área correta)
                    if (point.id === 'area_up_interaction' && currentArea === 'up') {
                        // Cache player apenas quando necessário
                        if (!playerCached) {
                            if (!this.cachedPlayer || this.playerCacheTime < Date.now() - 100) {
                                this.cachedPlayer = this.findPlayer();
                                this.playerCacheTime = Date.now();
                            }
                            playerCached = true;
                        }
                        
                        if (this.cachedPlayer) {
                            this.checkPlayerInInteractionAreaOptimized(point);
                        }
                    }
                });
            }

            // Buscar player com fallbacks
            findPlayer() {
                let player = this.gameClient.player;
                
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                return player;
            }

            // Versão otimizada da verificação do personagem
            checkPlayerInInteractionAreaOptimized(point) {
                const player = this.cachedPlayer;
                if (!player) return;

                // Throttling: só verificar a cada 5 frames (~83ms a 60fps)
                point.checkCounter = (point.checkCounter || 0) + 1;
                if (point.checkCounter % 5 !== 0) return;

                const wasPlayerInside = point.playerInside || false;
                // NOVA: Usar detecção de colisão entre retângulos ao invés de apenas um ponto
                const isPlayerInside = this.isPlayerColliding(player, point);

                // Personagem entrou na área de interação
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o áudio já foi tocado nesta sessão na área
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`🚪 Personagem colidiu com área de teleporte! Player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)}) Dimensões: ${player.width || 32}x${player.height || 32}`);
                        
                        // FREEZE o player imediatamente para animação de teleporte
                        if (player.freeze) {
                            player.freeze();
                        }
                        
                        // Reproduzir áudio de teleporte
                        this.playAudioImmediate('songs/tp_song.mp3');
                        
                        // Redirecionar após o áudio terminar (3.89s + margem = 4s)
                        setTimeout(() => {
                            console.log('🗡️ Portal Ativado! Redirecionando para o blog...');
                            window.location.href = 'pages/blog.html';
                        }, 4000); // 4 segundos para garantir que o áudio termine
                    } else {
                        console.log('🔇 Áudio já foi tocado nesta entrada na área');
                    }
                }
                
                // Personagem saiu da área de interação
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do áudio ao sair
                    
                    // Descongelar o player se ele saiu da área
                    if (player.unfreeze) {
                        player.unfreeze();
                    }
                    
                    console.log('🚶 Personagem saiu da área de teleporte - áudio resetado e player desfrozen');
                }
            }

            // Reproduzir áudio de forma mais eficiente
            playAudioImmediate(audioPath) {
                try {
                    console.log(`🎵 Tentando reproduzir áudio: ${audioPath}`);
                    if (window.audioManager) {
                        // Tentar múltiplos métodos de reprodução para garantir que funcione
                        audioManager.playAudioFast(audioPath);
                        
                        // Fallback: tentar método padrão também
                        setTimeout(() => {
                            audioManager.playAudio(audioPath);
                        }, 100);
                        
                        console.log('🎵 Comando de reprodução enviado');
                        
                        // Nota: Redirecionamento agora é controlado pela interação específica
                        // para permitir timing preciso com o freeze do player
                        
                    } else {
                        console.error('❌ AudioManager não disponível');
                    }
                } catch (error) {
                    console.error('❌ Erro ao reproduzir áudio:', error);
                }
            }

            // Verificar se o personagem está dentro da área de interação (método antigo - mantido para compatibilidade)
            checkPlayerInInteractionArea(point) {
                // Tentar múltiplas formas de acessar o player
                let player = this.gameClient.player;
                
                // Se não encontrar, tentar pelo gameCore
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                // Se ainda não encontrar, tentar pelo frameBasedGame
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                if (!player) {
                    console.log('🚫 Player não encontrado - verificando área só com mouse');
                    return;
                }

                const wasPlayerInside = point.playerInside || false;
                // NOVA: Usar detecção de colisão entre retângulos ao invés de apenas um ponto
                const isPlayerInside = this.isPlayerColliding(player, point);

                // Personagem entrou na área de interação
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o áudio já foi tocado nesta sessão na área
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`🚪 Personagem colidiu com área de teleporte! Player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)}) Dimensões: ${player.width || 32}x${player.height || 32}`);
                        
                        // Reproduzir áudio e redirecionar
                        if (window.audioManager) {
                            audioManager.playAudio('songs/tp_song.mp3');
                        }
                        
                        console.log('🎵 Portal ativado! Redirecionando para o blog...');
                        
                        // Redirecionar após delay para ouvir o áudio
                        setTimeout(() => {
                            window.location.href = 'pages/blog.html';
                        }, 800); // 800ms delay para ouvir o som completo
                    } else {
                        console.log('🔇 Áudio já foi tocado nesta entrada na área');
                    }
                }
                
                // Personagem saiu da área de interação
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do áudio ao sair
                    console.log('🚶 Personagem saiu da área de teleporte - áudio resetado');
                }
            }
        }

        // Teclas especiais
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                // Toggle debug de colisões
                if (window.gameCore) {
                    gameCore.collisionManager.debugMode = !gameCore.collisionManager.debugMode;
                    console.log('🐛 Debug de colisões:', gameCore.collisionManager.debugMode);
                }
            }
            
            if (e.key === 'F2') {
                // Toggle debug de interações
                if (window.gameCore) {
                    gameCore.interactionManager.debugMode = !gameCore.interactionManager.debugMode;
                    console.log('🐛 Debug de interações:', gameCore.interactionManager.debugMode);
                }
            }
            
            if (e.key === 'F3') {
                // Reset posição do player
                if (gameClient && gameClient.player) {
                    gameClient.player.x = 400;
                    gameClient.player.y = 300;
                    console.log('🔄 Posição resetada');
                }
            }
            
            if (e.key === 'F4') {
                // Reconectar ao servidor
                if (gameClient) {
                    console.log('🔄 Tentando reconectar...');
                    if (gameClient.gameState.isConnected) {
                        gameClient.disconnect();
                        setTimeout(() => {
                            gameClient.connect('Player').catch(err => {
                                console.log('❌ Falha na reconexão:', err.message);
                            });
                        }, 1000);
                    } else {
                        gameClient.connect('Player').catch(err => {
                            console.log('❌ Falha na conexão:', err.message);
                        });
                    }
                }
            }
        });

        // Botão de teste de conexão
        document.addEventListener('DOMContentLoaded', () => {
            const testButton = document.getElementById('testConnection');
            if (testButton) {
                testButton.addEventListener('click', async () => {
                    console.log('🧪 Iniciando teste de conexão...');
                    testButton.textContent = '🔄 Testando...';
                    testButton.disabled = true;
                    
                    try {
                        const networkManager = new NetworkManager();
                        await networkManager.connect({
                            name: 'TestPlayer',
                            color: '#00FF00'
                        });
                        
                        console.log('✅ Teste de conexão bem-sucedido!');
                        testButton.textContent = '✅ Conectado!';
                        testButton.style.background = '#4CAF50';
                        
                        // Desconectar após teste
                        setTimeout(() => {
                            networkManager.disconnect();
                            testButton.textContent = '🔗 Testar Conexão';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                        
                    } catch (error) {
                        console.error('❌ Teste de conexão falhou:', error);
                        testButton.textContent = '❌ Falhou';
                        testButton.style.background = '#f44336';
                        
                        setTimeout(() => {
                            testButton.textContent = '🔗 Testar Conexão';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                    }
                });
            }
        });

        // Inicializar quando a página carregar
        window.addEventListener('load', () => {
            initGame();
        });
    </script>

</body>
</html>