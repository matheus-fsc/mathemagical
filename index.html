<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: ws: wss: https: 'unsafe-inline'; connect-src 'self' ws: wss: https: data: blob:;">
    <title>ğŸ—¡ï¸ Link's Adventure Blog | A Legendary Journey</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="favicon.ico">
    <!-- CSS Styles -->
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/layout.css">
    <link rel="stylesheet" href="styles/game.css">
    <link rel="stylesheet" href="styles/buttons.css">
    <link rel="stylesheet" href="styles/panels.css">
    <link rel="stylesheet" href="styles/effects.css">
</head>
<body>
    <!-- Main Container -->
    <div class="main-container">
        
        <!-- Header Vintage -->
        <header class="vintage-header">
            <h1 class="title">ğŸ—¡ï¸ LINK'S ADVENTURE BLOG</h1>
            <p class="subtitle">~ A Legendary Journey Through Hyrule & Code ~</p>
        </header>

        <!-- Game Section -->
        <section class="game-section">
            <div class="game-container">
                <canvas id="gameCanvas"></canvas>
                <div class="game-status" id="gameStatus">
                    ğŸŸ¡ Modo Aventura Ativo
                </div>
                <div class="connection-status" id="connectionStatus" style="font-size: 12px; color: #666; margin-top: 5px; display: none;">
                    ğŸ”„ Conectando...
                </div>
            </div>
        </section>

        <!-- Navigation Section -->
        <section class="navigation-section">
            <nav class="interactive-buttons">
                <a href="#blog" class="zelda-button" data-target="blog" data-hitbox-x="0.15" data-hitbox-y="0.2">
                    <span class="button-icon">ğŸ“</span>
                    <span class="button-title">Blog Adventures</span>
                    <span class="button-desc">Jornadas e descobertas</span>
                </a>
                
                <a href="#projects" class="zelda-button" data-target="projects" data-hitbox-x="0.5" data-hitbox-y="0.2">
                    <span class="button-icon">ğŸ› ï¸</span>
                    <span class="button-title">Code Dungeons</span>
                    <span class="button-desc">Projetos e experimentos</span>
                </a>
                
                <a href="#gallery" class="zelda-button" data-target="gallery" data-hitbox-x="0.85" data-hitbox-y="0.2">
                    <span class="button-icon">ğŸ–¼ï¸</span>
                    <span class="button-title">Treasure Gallery</span>
                    <span class="button-desc">Arte e capturas</span>
                </a>
                
                <a href="#about" class="zelda-button" data-target="about" data-hitbox-x="0.15" data-hitbox-y="0.6">
                    <span class="button-icon">ğŸ‘¤</span>
                    <span class="button-title">Hero's Profile</span>
                    <span class="button-desc">Sobre o aventureiro</span>
                </a>
                
                <a href="#links" class="zelda-button" data-target="links" data-hitbox-x="0.5" data-hitbox-y="0.6">
                    <span class="button-icon">ğŸ”—</span>
                    <span class="button-title">Sacred Links</span>
                    <span class="button-desc">ConexÃµes importantes</span>
                </a>
                
                <a href="#contact" class="zelda-button" data-target="contact" data-hitbox-x="0.85" data-hitbox-y="0.6">
                    <span class="button-icon">ğŸ“¬</span>
                    <span class="button-title">Send a Message</span>
                    <span class="button-desc">Fale com o herÃ³i</span>
                </a>
            </nav>
        </section>

        <!-- Info Section -->
        <section class="info-section">
            <div class="info-panel">
                <h3>ğŸ® Como Navegar na Aventura</h3>
                <p>
                    Bem-vindo ao meu cantinho digital inspirado em Zelda! Use o Link para explorar e interagir com os elementos da pÃ¡gina. 
                    Move-se pelo mundo e ataque os botÃµes dourados para navegar pelas diferentes seÃ§Ãµes do blog.
                </p>
        
        <div class="controls-info">
            <div class="control-item">
                <span class="control-key">WASD / Setas:</span> Mover o Link
            </div>
            <div class="control-item">
                    <div class="controls-info">
                    <div class="control-item">
                        <span class="control-key">WASD / Setas:</span> Mover Link
                    </div>
                    <div class="control-item">
                        <span class="control-key">X / Z / Enter:</span> Atacar botÃµes
                    </div>
                    <div class="control-item">
                        <span class="control-key">F1:</span> Mostrar/ocultar debug
                    </div>
                    <div class="control-item">
                        <span class="control-key">F2:</span> Reset posiÃ§Ã£o
                    </div>
                    <div class="control-item">
                        <span class="control-key">F4:</span> Reconectar servidor
                    </div>
                    <div class="control-item">
                        <button id="testConnection" class="control-key" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; cursor: pointer;">ğŸ”— Testar ConexÃ£o</button>
                    </div>
                </div>
            </div>

            <div class="info-panel">
                <h3>ğŸŒŸ Sobre Este Blog</h3>
                <p>
                    Este Ã© meu espaÃ§o pessoal onde compartilho aventuras em programaÃ§Ã£o, projetos criativos e reflexÃµes sobre tecnologia. 
                    Inspirado na nostalgia dos primeiros sites da internet e na magia atemporal de The Legend of Zelda.
                </p>
                <p>
                    Cada seÃ§Ã£o Ã© uma dungeon diferente com seus prÃ³prios tesouros e segredos. Explore Ã  vontade e descubra o que cada 
                    Ã¡rea tem para oferecer! Os botÃµes dourados sÃ£o pontos de interaÃ§Ã£o - aproxime-se e ataque para ativÃ¡-los.
                </p>
            </div>
        </section>

        <!-- Footer -->
        <footer class="vintage-footer">
            <p>âš”ï¸ Link's Adventure Blog - Crafted with â¤ï¸ and nostalgia âš”ï¸</p>
            <div class="visitor-counter">
                Visitors: 001337
            </div>
            <p style="font-size: 0.8rem; margin-top: 10px; color: #888;">
                "It's dangerous to go alone! Take this website." - Old Man, 2025
            </p>
        </footer>
        
    </div> <!-- End main-container -->

  <!-- Game Scripts -->
<script src="socket.io.min.js?v=1.0.0"></script>
<script>
  // Debug: Verificar se Socket.io foi carregado
  console.log('ğŸ” Socket.io disponÃ­vel:', typeof io !== 'undefined' ? 'âœ… SIM' : 'âŒ NÃƒO');
  if (typeof io !== 'undefined') {
    console.log('ğŸ“¦ Socket.io version:', io.version || 'unknown');
  }
</script>
<script src="config/serverConfig.js"></script>
<script src="legacy/areaManager.js"></script>
<script src="input/inputManager.js"></script>
<script src="sprites/frameBasedSpriteManager.js"></script>
<script src="legacy/frameBasedPlayer.js"></script>
<script src="network/mockServer.js"></script>
<script>
  // Debug: Verificar se MockServer foi carregado
  console.log('ğŸ¤– MockServer disponÃ­vel:', typeof MockServer !== 'undefined' ? 'âœ… SIM' : 'âŒ NÃƒO');
</script>
<script src="network/networkManager.js"></script>
<script src="network/multiplayerManager.js"></script>

<!-- Component System -->
<script src="managers/AssetLoader.js"></script>
<script src="managers/SceneManager.js"></script>
<script src="managers/CollisionManager.js"></script>
<script src="managers/InteractionManager.js"></script>
<script src="components/GameCore.js"></script>

<script src="core/gameClient.js"></script>

    <script>
        // InicializaÃ§Ã£o do jogo
        let gameClient = null;

        // Inicializar jogo
        async function initGame() {
            try {
                // Configurar canvas responsivo
                setupResponsiveCanvas();
                
                gameClient = new GameClient();
                await gameClient.init('gameCanvas');
                
                // Sistema de Ã¡udio
                const audioManager = {
                    audio: null,
                    
                    loadAudio(src) {
                        if (!this.audio) {
                            this.audio = new Audio(src);
                            this.audio.preload = 'auto';
                            this.audio.volume = 0.5; // Volume padrÃ£o 50%
                        }
                        return this.audio;
                    },
                    
                    playAudio(src = 'songs/tp_song.mp3') {
                        try {
                            const audio = this.loadAudio(src);
                            audio.currentTime = 0; // Restart from beginning
                            const playPromise = audio.play();
                            
                            if (playPromise !== undefined) {
                                playPromise
                                    .then(() => {
                                        console.log('ğŸµ Ãudio reproduzido com sucesso:', src);
                                    })
                                    .catch(error => {
                                        console.warn('âš ï¸ Autoplay bloqueado, necessÃ¡ria interaÃ§Ã£o do usuÃ¡rio:', error);
                                    });
                            }
                        } catch (error) {
                            console.error('âŒ Erro ao reproduzir Ã¡udio:', error);
                        }
                    },
                    
                    stopAudio() {
                        if (this.audio) {
                            this.audio.pause();
                            this.audio.currentTime = 0;
                        }
                    }
                };
                
                // Tornar o audioManager global
                window.audioManager = audioManager;
                
                // Inicializar sistema de componentes
                window.gameCore = new GameCore();
                await gameCore.init('gameCanvas');
                
                // Integrar com o sistema legado
                gameCore.integrateWithLegacySystem(gameClient);
                
                // Inicializar sistema de interaÃ§Ã£o com mouse
                gameClient.mouseManager = new MouseInteractionManager(gameClient);
                
                // Ponto de interaÃ§Ã£o na Ã¡rea "up" - coordenadas especÃ­ficas
                const interactionX = 355;      // top left x
                const interactionY = 362;      // top left y
                const interactionWidth = 76.9;  // mantÃ©m o mesmo tamanho
                const interactionHeight = 50.5; // mantÃ©m o mesmo tamanho
                
                gameClient.mouseManager.addInteractionPoint(
                    interactionX,        // x
                    interactionY,        // y
                    interactionWidth,    // width
                    interactionHeight,   // height
                    (mousePos, point) => {
                        // SÃ³ funciona na Ã¡rea "up"
                        if (gameClient.areaManager && gameClient.areaManager.getCurrentArea() === 'up') {
                            // Reproduzir Ã¡udio de teleporte
                            if (window.audioManager) {
                                audioManager.playAudio('songs/tp_song.mp3');
                            }
                            alert(`ğŸ—¡ï¸ Portal Ativado! ğŸµ\nCoordenadas: (${mousePos.x.toFixed(1)}, ${mousePos.y.toFixed(1)})\nÃudio: tp_song.mp3`);
                        } else {
                            console.log('ğŸš« Esta interaÃ§Ã£o sÃ³ funciona na Ã¡rea UP');
                        }
                    },
                    'area_up_interaction'
                );
                
                // FunÃ§Ã£o helper para facilitar criaÃ§Ã£o de pontos de interaÃ§Ã£o
                window.addInteractionPoint = (x, y, width, height, action, id) => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.addInteractionPoint(x, y, width, height, action, id);
                    }
                };
                
                window.removeInteractionPoint = (id) => {
                    if (gameClient && gameClient.mouseManager) {
                        gameClient.mouseManager.removeInteractionPoint(id);
                    }
                };
                
                // Helper para obter posiÃ§Ã£o do mouse facilmente
                window.getMousePos = () => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.currentMousePos;
                    }
                    return { x: -1, y: -1 };
                };
                
                
                // Configurar redimensionamento
                window.addEventListener('resize', () => {
                    setupResponsiveCanvas();
                });
                
                // Iniciar game loop
                startGameLoop();
                
                // Atualizar status do jogo
                updateGameStatus();
                
                console.log('ğŸ® Blog interativo inicializado com sucesso!');
                
                // ===== CONEXÃƒO AUTOMÃTICA AO SERVIDOR =====
                console.log('ğŸ”— Iniciando conexÃ£o automÃ¡tica...');
                showConnectionStatus('ğŸ”„ Conectando ao servidor...', true);
                
                try {
                    await gameClient.connect('Player');
                    console.log('âœ… Conectado automaticamente ao servidor multiplayer!');
                    showConnectionStatus('âœ… Conectado!', false);
                } catch (error) {
                    console.log('âš ï¸ Falha na conexÃ£o automÃ¡tica, continuando em modo singleplayer:', error.message);
                    showConnectionStatus('âš ï¸ Modo offline', false);
                    // NÃ£o Ã© um erro crÃ­tico - o jogo continua funcionando offline
                }
                
        // Configurar canvas responsivo
        function setupResponsiveCanvas() {
            const canvas = document.getElementById('gameCanvas');
            const container = canvas.parentElement;
            
            // Obter dimensÃµes do container
            const containerRect = container.getBoundingClientRect();
            
            // Usar dimensÃµes mais flexÃ­veis para melhor responsividade
            // Permitir que o canvas use o mÃ¡ximo de espaÃ§o disponÃ­vel
            let canvasWidth = Math.max(containerRect.width - 8, 400); // MÃ­nimo 400px
            let canvasHeight = Math.max(containerRect.height - 8, 300); // MÃ­nimo 300px
            
            // Aplicar uma proporÃ§Ã£o mÃ¡xima para telas muito largas
            const maxAspectRatio = 16/9; // MÃ¡ximo ultra-wide
            const minAspectRatio = 4/3;  // MÃ­nimo tradicional
            
            const currentRatio = canvasWidth / canvasHeight;
            
            if (currentRatio > maxAspectRatio) {
                // Muito largo - ajustar largura
                canvasWidth = canvasHeight * maxAspectRatio;
            } else if (currentRatio < minAspectRatio) {
                // Muito alto - ajustar altura
                canvasHeight = canvasWidth / minAspectRatio;
            }
            
            // Garantir que nÃ£o exceda container
            if (canvasWidth > containerRect.width - 8) {
                canvasWidth = containerRect.width - 8;
                canvasHeight = canvasWidth / (currentRatio > maxAspectRatio ? maxAspectRatio : currentRatio);
            }
            
            if (canvasHeight > containerRect.height - 8) {
                canvasHeight = containerRect.height - 8;
                canvasWidth = canvasHeight * (currentRatio < minAspectRatio ? minAspectRatio : currentRatio);
            }
            
            // Definir dimensÃµes do canvas (valores inteiros para melhor renderizaÃ§Ã£o)
            canvas.width = Math.floor(canvasWidth);
            canvas.height = Math.floor(canvasHeight);
            
            console.log(`Canvas redimensionado para: ${canvas.width}x${canvas.height} (ratio: ${(canvas.width/canvas.height).toFixed(2)})`);
        }
                
        } catch (error) {
            console.error('âŒ Erro ao inicializar:', error);
        }
    }
        
    // ===== FUNÃ‡Ã•ES DE UTILITY =====
    
    // Mostrar status de conexÃ£o
    function showConnectionStatus(message, show = true) {
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.style.display = show ? 'block' : 'none';
            
            // Auto-hide depois de 5 segundos se nÃ£o for um status de loading
            if (show && !message.includes('ğŸ”„')) {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 5000);
            }
        }
    }
    
    // Atualizar status de retry
    function updateRetryStatus(attempt, maxAttempts, url, delay = 0) {
        const isRender = url.includes('render.com');
        const serverType = isRender ? 'Render' : 'servidor';
        
        if (delay > 0) {
            showConnectionStatus(`â³ Aguardando ${Math.round(delay/1000)}s para retry ${attempt}/${maxAttempts} (${serverType})`, true);
        } else {
            showConnectionStatus(`ğŸ”„ Tentativa ${attempt}/${maxAttempts} - ${serverType}${isRender ? ' (pode estar em sleep)' : ''}`, true);
        }
    }

    // Game loop
        let lastTime = 0;
        function startGameLoop() {
            function gameLoop(currentTime) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                if (gameClient) {
                    gameClient.update(deltaTime);
                    gameClient.render();
                }

                requestAnimationFrame(gameLoop);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Atualizar status do jogo
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            
            setInterval(() => {
                if (gameClient) {
                    let status = 'ğŸ”´ Parado';
                    
                    if (gameClient.gameState.isConnected) {
                        const playerCount = gameClient.gameState.players ? Object.keys(gameClient.gameState.players).length : 1;
                        status = `ğŸŸ¢ Multiplayer (${playerCount} jogador${playerCount > 1 ? 'es' : ''})`;
                    } else if (gameClient.gameState.isGameRunning) {
                        status = 'ğŸŸ¡ Modo Aventura Solo';
                    }
                    
                    statusElement.textContent = status;
                }
            }, 1000);
        }

        // FunÃ§Ã£o para obter coordenadas do mouse em relaÃ§Ã£o a uma div/element
        function getMousePosition(event, element) {
            const rect = element.getBoundingClientRect();
            const scaleX = element.width / rect.width;   // Escala X do canvas
            const scaleY = element.height / rect.height; // Escala Y do canvas
            
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY,
                // Coordenadas brutas (sem escala) caso precise
                rawX: event.clientX - rect.left,
                rawY: event.clientY - rect.top,
                // InformaÃ§Ãµes da div
                elementRect: rect
            };
        }

        // Sistema de pontos de interaÃ§Ã£o via mouse
        class MouseInteractionManager {
            constructor(gameClient) {
                this.gameClient = gameClient;
                this.canvas = gameClient.canvas;
                this.interactionPoints = [];
                this.isMouseDown = false;
                this.currentMousePos = { x: 0, y: 0 };
                
                this.setupMouseEvents();
                console.log('ğŸ–±ï¸ MouseInteractionManager inicializado');
            }

            setupMouseEvents() {
                // Rastrear movimento do mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    this.currentMousePos = getMousePosition(e, this.canvas);
                    this.checkInteractions();
                });

                // Clique do mouse
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    const mousePos = getMousePosition(e, this.canvas);
                    this.handleClick(mousePos);
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    this.isMouseDown = false;
                });

                // Deixar Ã¡rea do canvas
                this.canvas.addEventListener('mouseleave', (e) => {
                    this.currentMousePos = { x: -1, y: -1 };
                });
            }

            // Adicionar ponto de interaÃ§Ã£o
            addInteractionPoint(x, y, width, height, action, id = null) {
                const point = {
                    id: id || `point_${this.interactionPoints.length}`,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    action: action,
                    isHovered: false,
                    cooldown: 0
                };
                
                this.interactionPoints.push(point);
                console.log(`ğŸ¯ Ponto de interaÃ§Ã£o adicionado: ${point.id} em (${x}, ${y})`);
                return point;
            }

            // Remover ponto de interaÃ§Ã£o
            removeInteractionPoint(id) {
                this.interactionPoints = this.interactionPoints.filter(point => point.id !== id);
                console.log(`ğŸ—‘ï¸ Ponto de interaÃ§Ã£o removido: ${id}`);
            }

            // Verificar se ponto estÃ¡ dentro da Ã¡rea
            isPointInside(mousePos, area) {
                return mousePos.x >= area.x && 
                       mousePos.x <= area.x + area.width &&
                       mousePos.y >= area.y && 
                       mousePos.y <= area.y + area.height;
            }

            // Eventos de hover
            onPointEnter(point) {
                this.canvas.style.cursor = 'pointer';
                console.log(`ğŸ¯ Mouse entrou na Ã¡rea: ${point.id}`);
            }

            onPointLeave(point) {
                this.canvas.style.cursor = 'default';
                console.log(`ğŸ¯ Mouse saiu da Ã¡rea: ${point.id}`);
            }

            // Manipular clique
            handleClick(mousePos) {
                this.interactionPoints.forEach(point => {
                    if (this.isPointInside(mousePos, point) && point.cooldown === 0) {
                        console.log(`ğŸ–±ï¸ Clique em: ${point.id} na posiÃ§Ã£o (${mousePos.x.toFixed(1)}, ${mousePos.y.toFixed(1)})`);
                        
                        // Executar aÃ§Ã£o
                        if (typeof point.action === 'function') {
                            point.action(mousePos, point);
                        }
                        
                        // Cooldown para evitar spam
                        point.cooldown = 30; // ~0.5 segundos
                    }
                });
            }

            // Renderizar Ã¡reas de debug
            renderDebugAreas(ctx) {
                if (!this.gameClient.debug.enabled) return;

                ctx.save();
                
                this.interactionPoints.forEach(point => {
                    // Ãrea de interaÃ§Ã£o
                    ctx.strokeStyle = point.isHovered ? '#00FF00' : '#FF6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(point.x, point.y, point.width, point.height);
                    
                    // Label
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.fillText(point.id, point.x, point.y - 5);
                    
                    // Highlight se estiver hovering
                    if (point.isHovered) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                        ctx.fillRect(point.x, point.y, point.width, point.height);
                    }
                });

                // Mostrar posiÃ§Ã£o atual do mouse
                if (this.currentMousePos.x >= 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(this.currentMousePos.x, this.currentMousePos.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Coordenadas
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '10px Arial';
                    ctx.fillText(`(${this.currentMousePos.x.toFixed(0)}, ${this.currentMousePos.y.toFixed(0)})`, 
                                this.currentMousePos.x + 5, this.currentMousePos.y - 5);
                }
                
                ctx.restore();
            }

            // Atualizar visibilidade das interaÃ§Ãµes baseada na Ã¡rea atual
            updateInteractionsForArea(currentArea) {
                this.interactionPoints.forEach(point => {
                    // InteraÃ§Ã£o area_up_interaction sÃ³ funciona na Ã¡rea "up"
                    if (point.id === 'area_up_interaction') {
                        point.visible = (currentArea === 'up');
                        if (!point.visible) {
                            point.isHovered = false; // Reset hover se nÃ£o estiver visÃ­vel
                        }
                    }
                });
            }

            // Verificar interaÃ§Ãµes - agora considera visibilidade
            checkInteractions() {
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                this.interactionPoints.forEach(point => {
                    // SÃ³ processar interaÃ§Ãµes visÃ­veis na Ã¡rea atual
                    if (point.id === 'area_up_interaction' && currentArea !== 'up') {
                        point.isHovered = false; // Reset hover se nÃ£o estiver na Ã¡rea correta
                        return; // Skip processamento
                    }

                    if (point.cooldown > 0) {
                        point.cooldown--;
                    }

                    const wasHovered = point.isHovered;
                    point.isHovered = this.isPointInside(this.currentMousePos, point);

                    // Entrou na Ã¡rea
                    if (point.isHovered && !wasHovered) {
                        this.onPointEnter(point);
                    }
                    
                    // Saiu da Ã¡rea
                    if (!point.isHovered && wasHovered) {
                        this.onPointLeave(point);
                    }

                    // Verificar se o personagem estÃ¡ dentro da Ã¡rea de interaÃ§Ã£o (especial para area_up_interaction)
                    if (point.id === 'area_up_interaction' && currentArea === 'up') {
                        this.checkPlayerInInteractionArea(point);
                    }
                });
            }

            // Verificar se o personagem estÃ¡ dentro da Ã¡rea de interaÃ§Ã£o
            checkPlayerInInteractionArea(point) {
                // Tentar mÃºltiplas formas de acessar o player
                let player = this.gameClient.player;
                
                // Se nÃ£o encontrar, tentar pelo gameCore
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                // Se ainda nÃ£o encontrar, tentar pelo frameBasedGame
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                if (!player) {
                    console.log('ğŸš« Player nÃ£o encontrado - verificando Ã¡rea sÃ³ com mouse');
                    return;
                }

                const playerPos = {
                    x: player.x,
                    y: player.y
                };

                const wasPlayerInside = point.playerInside || false;
                const isPlayerInside = this.isPointInside(playerPos, point);

                // Personagem entrou na Ã¡rea de interaÃ§Ã£o
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o Ã¡udio jÃ¡ foi tocado nesta sessÃ£o na Ã¡rea
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`ğŸšª Personagem entrou na Ã¡rea de teleporte! Pos: (${playerPos.x.toFixed(1)}, ${playerPos.y.toFixed(1)})`);
                        
                        // Reproduzir Ã¡udio automaticamente (apenas uma vez)
                        if (window.audioManager) {
                            audioManager.playAudio('songs/tp_song.mp3');
                        }
                        
                        console.log('ğŸµ Tocando tp_song.mp3 - Portal ativado!');
                    } else {
                        console.log('ğŸ”‡ Ãudio jÃ¡ foi tocado nesta entrada na Ã¡rea');
                    }
                }
                
                // Personagem saiu da Ã¡rea de interaÃ§Ã£o
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do Ã¡udio ao sair
                    console.log('ğŸš¶ Personagem saiu da Ã¡rea de teleporte - Ã¡udio resetado');
                }
            }
        }

        // Teclas especiais
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                // Toggle debug de colisÃµes
                if (window.gameCore) {
                    gameCore.collisionManager.debugMode = !gameCore.collisionManager.debugMode;
                    console.log('ğŸ› Debug de colisÃµes:', gameCore.collisionManager.debugMode);
                }
            }
            
            if (e.key === 'F2') {
                // Toggle debug de interaÃ§Ãµes
                if (window.gameCore) {
                    gameCore.interactionManager.debugMode = !gameCore.interactionManager.debugMode;
                    console.log('ğŸ› Debug de interaÃ§Ãµes:', gameCore.interactionManager.debugMode);
                }
            }
            
            if (e.key === 'F3') {
                // Reset posiÃ§Ã£o do player
                if (gameClient && gameClient.player) {
                    gameClient.player.x = 400;
                    gameClient.player.y = 300;
                    console.log('ğŸ”„ PosiÃ§Ã£o resetada');
                }
            }
            
            if (e.key === 'F4') {
                // Reconectar ao servidor
                if (gameClient) {
                    console.log('ğŸ”„ Tentando reconectar...');
                    if (gameClient.gameState.isConnected) {
                        gameClient.disconnect();
                        setTimeout(() => {
                            gameClient.connect('Player').catch(err => {
                                console.log('âŒ Falha na reconexÃ£o:', err.message);
                            });
                        }, 1000);
                    } else {
                        gameClient.connect('Player').catch(err => {
                            console.log('âŒ Falha na conexÃ£o:', err.message);
                        });
                    }
                }
            }
        });

        // BotÃ£o de teste de conexÃ£o
        document.addEventListener('DOMContentLoaded', () => {
            const testButton = document.getElementById('testConnection');
            if (testButton) {
                testButton.addEventListener('click', async () => {
                    console.log('ğŸ§ª Iniciando teste de conexÃ£o...');
                    testButton.textContent = 'ğŸ”„ Testando...';
                    testButton.disabled = true;
                    
                    try {
                        const networkManager = new NetworkManager();
                        await networkManager.connect({
                            name: 'TestPlayer',
                            color: '#00FF00'
                        });
                        
                        console.log('âœ… Teste de conexÃ£o bem-sucedido!');
                        testButton.textContent = 'âœ… Conectado!';
                        testButton.style.background = '#4CAF50';
                        
                        // Desconectar apÃ³s teste
                        setTimeout(() => {
                            networkManager.disconnect();
                            testButton.textContent = 'ğŸ”— Testar ConexÃ£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                        
                    } catch (error) {
                        console.error('âŒ Teste de conexÃ£o falhou:', error);
                        testButton.textContent = 'âŒ Falhou';
                        testButton.style.background = '#f44336';
                        
                        setTimeout(() => {
                            testButton.textContent = 'ğŸ”— Testar ConexÃ£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                    }
                });
            }
        });

        // Inicializar quando a pÃ¡gina carregar
        window.addEventListener('load', initGame);
    </script>

</body>
</html>