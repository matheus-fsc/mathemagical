<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: ws: wss: https: 'unsafe-inline'; connect-src 'self' ws: wss: https: data: blob:;">
    <title>üó°Ô∏è Link's Adventure Blog | A Legendary Journey</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="favicon.ico">
    
    <!-- Fixed Size Canvas Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            display: block;
            width: 800px;  /* Largura fixa */
            height: 600px; /* Altura fixa */
            background: #000;
            border: 2px solid #333;
            image-rendering: pixelated; /* Para manter sprites n√≠tidos */
        }
        
        .debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 12px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
            display: none;
        }
        
        /* Audio Permission Modal */
        .audio-permission-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            font-family: 'Courier New', monospace;
        }
        
        .audio-permission-content {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            border: 3px solid #FFD700;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
        }
        
        .audio-permission-title {
            font-size: 24px;
            color: #FFD700;
            margin-bottom: 15px;
        }
        
        .audio-permission-text {
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 25px;
            color: #ecf0f1;
        }
        
        .audio-permission-button {
            background: #e74c3c;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }
        
        .audio-permission-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        /* ===== VIRTUAL JOYSTICK STYLES ===== */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none; /* Oculto por padr√£o, mostrado apenas em mobile */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.4);
            position: relative;
            box-shadow: 
                0 0 20px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            
            /* Indicador central sutil */
            &::before {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.3);
                transform: translate(-50%, -50%);
            }
        }
        
        .joystick-base:active {
            transform: scale(1.05);
            border-color: rgba(255, 215, 0, 0.6);
            box-shadow: 
                0 0 30px rgba(255, 215, 0, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #FFD700, #FFA500);
            border: 2px solid rgba(255, 255, 255, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 4px 15px rgba(0, 0, 0, 0.4),
                inset 0 2px 5px rgba(255, 255, 255, 0.3);
            transition: all 0.1s ease;
            cursor: pointer;
            
            /* Highlight central */
            &::before {
                content: '';
                position: absolute;
                top: 20%;
                left: 30%;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.6);
                filter: blur(1px);
            }
        }
        
        .joystick-knob:active {
            background: radial-gradient(circle at 30% 30%, #FFA500, #FF8C00);
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        /* Responsive para diferentes tamanhos de tela mobile */
        @media (max-width: 480px) {
            .virtual-joystick {
                bottom: 20px;
                left: 20px;
            }
            
            .joystick-base {
                width: 100px;
                height: 100px;
            }
            
            .joystick-knob {
                width: 40px;
                height: 40px;
            }
        }
        
        @media (max-height: 600px) {
            .virtual-joystick {
                bottom: 15px;
                left: 15px;
            }
            
            .joystick-base {
                width: 90px;
                height: 90px;
            }
            
            .joystick-knob {
                width: 35px;
                height: 35px;
            }
        }
        
        /* Orienta√ß√£o landscape em mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .virtual-joystick {
                bottom: 10px;
                left: 15px;
                transform: scale(0.8);
            }
        }
        
        /* Dispositivos com notch */
        @supports (padding: max(0px)) {
            .virtual-joystick {
                bottom: max(30px, env(safe-area-inset-bottom));
                left: max(30px, env(safe-area-inset-left));
            }
        }
    </style>
</head>
<body>
    <!-- Fullscreen Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Mobile Virtual Joystick -->
    <div class="virtual-joystick" id="virtualJoystick">
        <div class="joystick-base" id="joystickBase">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>
    
    <!-- Audio Permission Modal -->
    <div class="audio-permission-modal" id="audioPermissionModal">
        <div class="audio-permission-content">
            <div class="audio-permission-title">üéµ Aventura Sonora</div>
            <div class="audio-permission-text">
                Para uma experi√™ncia completa, este jogo usa efeitos sonoros e m√∫sica de fundo. 
                <br><br>
                <strong>Clique para permitir √°udio e come√ßar sua aventura!</strong>
            </div>
            <button class="audio-permission-button" onclick="enableAudio()">
                üó°Ô∏è Iniciar Aventura com Som
            </button>
        </div>
    </div>
    
    <!-- Debug Info (Hidden by default) -->
    <div class="debug-info" id="debugInfo">
        Debug Mode: ON
    </div>

  <!-- Game Scripts -->
<script src="socket.io.min.js?v=1.0.0"></script>
<script>
  // Debug: Verificar se Socket.io foi carregado
  console.log('üîç Socket.io dispon√≠vel:', typeof io !== 'undefined' ? '‚úÖ SIM' : '‚ùå N√ÉO');
  if (typeof io !== 'undefined') {
    console.log('üì¶ Socket.io version:', io.version || 'unknown');
  }
</script>
<script src="config/serverConfig.js"></script>
<script src="legacy/areaManager.js"></script>
<script src="input/inputManager.js"></script>
<script src="sprites/frameBasedSpriteManager.js"></script>
<script src="legacy/frameBasedPlayer.js"></script>
<script src="network/mockServer.js"></script>
<script>
  // Debug: Verificar se MockServer foi carregado
  console.log('ü§ñ MockServer dispon√≠vel:', typeof MockServer !== 'undefined' ? '‚úÖ SIM' : '‚ùå N√ÉO');
</script>
<script src="network/networkManager.js"></script>
<script src="network/multiplayerManager.js"></script>

<!-- Component System -->
<script src="managers/AssetLoader.js"></script>
<script src="managers/SceneManager.js"></script>
<script src="managers/CollisionManager.js"></script>
<script src="managers/InteractionManager.js"></script>
<script src="components/GameCore.js"></script>

<script src="core/gameClient.js"></script>

    <script>
        // ===== SISTEMA DE PERMISS√ÉO DE √ÅUDIO =====
        let audioEnabled = false;
        
        // Sistema de √°udio global e simples
        window.audioManager = {
            audioCache: new Map(),
            currentBackgroundMusic: null,
            isBackgroundPlaying: false,
            
            preloadAudio(src) {
                if (!this.audioCache.has(src)) {
                    const audio = new Audio(src);
                    audio.preload = 'auto';
                    audio.volume = 0.5;
                    audio.load();
                    this.audioCache.set(src, audio);
                    console.log('üéµ √Åudio pr√©-carregado:', src);
                }
                return this.audioCache.get(src);
            },
            
            startBackgroundMusic(src = 'songs/backgroundsond.mp3', volume = 0.3) {
                if (!audioEnabled) {
                    console.log('üîá √Åudio n√£o habilitado - m√∫sica de fundo n√£o iniciada');
                    return;
                }
                
                try {
                    this.stopBackgroundMusic();
                    const audio = this.preloadAudio(src);
                    audio.loop = true;
                    audio.volume = volume;
                    
                    audio.play().then(() => {
                        this.currentBackgroundMusic = audio;
                        this.isBackgroundPlaying = true;
                        console.log('üéµ M√∫sica de fundo iniciada:', src);
                    }).catch(error => {
                        console.warn('‚ö†Ô∏è Erro ao tocar m√∫sica de fundo:', error);
                    });
                } catch (error) {
                    console.error('‚ùå Erro no sistema de √°udio:', error);
                }
            },
            
            stopBackgroundMusic() {
                if (this.currentBackgroundMusic) {
                    this.currentBackgroundMusic.pause();
                    this.currentBackgroundMusic.currentTime = 0;
                    this.currentBackgroundMusic = null;
                    this.isBackgroundPlaying = false;
                }
            },
            
            playAudioFast(src = 'songs/tp_song.mp3') {
                if (!audioEnabled) {
                    console.log('üîá √Åudio n√£o habilitado - efeito sonoro n√£o reproduzido');
                    return;
                }
                
                try {
                    const audio = this.preloadAudio(src);
                    audio.currentTime = 0;
                    audio.play().then(() => {
                        console.log('üéµ Efeito sonoro reproduzido:', src);
                    }).catch(e => {
                        console.warn('‚ö†Ô∏è Erro ao reproduzir efeito sonoro:', e);
                    });
                } catch (error) {
                    console.error('‚ùå Erro ao reproduzir √°udio:', error);
                }
            },
            
            playAudio(src = 'songs/tp_song.mp3') {
                this.playAudioFast(src);
            }
        };
        
        // ===== VIRTUAL JOYSTICK CLASS =====
        class VirtualJoystick {
            constructor() {
                this.joystickElement = document.getElementById('virtualJoystick');
                this.baseElement = document.getElementById('joystickBase');
                this.knobElement = document.getElementById('joystickKnob');
                
                this.isActive = false;
                this.startPos = { x: 0, y: 0 };
                this.currentPos = { x: 0, y: 0 };
                this.direction = { x: 0, y: 0 }; // Valores normalizados entre -1 e 1
                this.magnitude = 0; // Intensidade do movimento (0 a 1)
                
                this.baseRadius = 60; // Raio da base do joystick
                this.knobRadius = 25; // Raio do knob
                this.maxDistance = this.baseRadius - this.knobRadius; // Dist√¢ncia m√°xima do knob do centro
                
                this.onMoveCallback = null;
                this.onStartCallback = null;
                this.onEndCallback = null;
                
                this.setupEvents();
                this.detectMobileDevice();
                
                console.log('üïπÔ∏è VirtualJoystick inicializado');
            }
            
            detectMobileDevice() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                                 'ontouchstart' in window ||
                                 navigator.maxTouchPoints > 0;
                
                if (isMobile) {
                    this.joystickElement.style.display = 'block';
                    console.log('üì± Dispositivo m√≥vel detectado - joystick virtual habilitado');
                } else {
                    this.joystickElement.style.display = 'none';
                    console.log('üñ•Ô∏è Dispositivo desktop detectado - joystick virtual desabilitado');
                }
                
                return isMobile;
            }
            
            setupEvents() {
                // Touch events para mobile
                this.baseElement.addEventListener('touchstart', this.onStart.bind(this), { passive: false });
                this.baseElement.addEventListener('touchmove', this.onMove.bind(this), { passive: false });
                this.baseElement.addEventListener('touchend', this.onEnd.bind(this), { passive: false });
                
                // Mouse events para teste em desktop
                this.baseElement.addEventListener('mousedown', this.onStart.bind(this));
                document.addEventListener('mousemove', this.onMove.bind(this));
                document.addEventListener('mouseup', this.onEnd.bind(this));
                
                // Prevenir scroll ao tocar no joystick
                this.baseElement.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            }
            
            onStart(event) {
                event.preventDefault();
                this.isActive = true;
                
                const touch = event.touches ? event.touches[0] : event;
                const rect = this.baseElement.getBoundingClientRect();
                
                this.startPos = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                
                this.currentPos = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                
                this.updateKnobPosition();
                
                if (this.onStartCallback) {
                    this.onStartCallback(this.direction, this.magnitude);
                }
                
                console.log('üïπÔ∏è Joystick ativado');
            }
            
            onMove(event) {
                if (!this.isActive) return;
                
                event.preventDefault();
                const touch = event.touches ? event.touches[0] : event;
                
                this.currentPos = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                
                this.updateKnobPosition();
                
                if (this.onMoveCallback) {
                    this.onMoveCallback(this.direction, this.magnitude);
                }
            }
            
            onEnd(event) {
                if (!this.isActive) return;
                
                event.preventDefault();
                this.isActive = false;
                
                // Retornar knob para o centro
                this.direction = { x: 0, y: 0 };
                this.magnitude = 0;
                this.knobElement.style.transform = 'translate(-50%, -50%)';
                
                if (this.onEndCallback) {
                    this.onEndCallback(this.direction, this.magnitude);
                }
                
                console.log('üïπÔ∏è Joystick desativado');
            }
            
            updateKnobPosition() {
                const deltaX = this.currentPos.x - this.startPos.x;
                const deltaY = this.currentPos.y - this.startPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Limitar movimento do knob dentro da base
                const clampedDistance = Math.min(distance, this.maxDistance);
                const angle = Math.atan2(deltaY, deltaX);
                
                const knobX = Math.cos(angle) * clampedDistance;
                const knobY = Math.sin(angle) * clampedDistance;
                
                // Atualizar posi√ß√£o visual do knob
                this.knobElement.style.transform = `translate(-50%, -50%) translate(${knobX}px, ${knobY}px)`;
                
                // Calcular dire√ß√£o normalizada (-1 a 1)
                this.direction = {
                    x: clampedDistance > 0 ? knobX / this.maxDistance : 0,
                    y: clampedDistance > 0 ? knobY / this.maxDistance : 0
                };
                
                // Calcular magnitude (0 a 1)
                this.magnitude = clampedDistance / this.maxDistance;
            }
            
            // M√©todos para configurar callbacks
            setOnMove(callback) {
                this.onMoveCallback = callback;
            }
            
            setOnStart(callback) {
                this.onStartCallback = callback;
            }
            
            setOnEnd(callback) {
                this.onEndCallback = callback;
            }
            
            // Getter para verificar se est√° ativo
            get active() {
                return this.isActive;
            }
            
            // Getter para dire√ß√£o atual
            get currentDirection() {
                return { ...this.direction };
            }
            
            // Getter para magnitude atual
            get currentMagnitude() {
                return this.magnitude;
            }
        }
        
        // Fun√ß√£o para habilitar √°udio ap√≥s intera√ß√£o do usu√°rio
        function enableAudio() {
            console.log('üéµ Usu√°rio solicitou habilita√ß√£o de √°udio');
            audioEnabled = true;
            
            // Esconder modal
            const modal = document.getElementById('audioPermissionModal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            console.log('üéµ Habilitando sistema de √°udio...');
            
            // Tocar um som silencioso para desbloquear o contexto de √°udio
            const testAudio = new Audio();
            testAudio.volume = 0;
            testAudio.play().then(() => {
                console.log('‚úÖ Contexto de √°udio desbloqueado');
                
                // Pr√©-carregar √°udios cr√≠ticos
                window.audioManager.preloadAudio('songs/backgroundsond.mp3');
                window.audioManager.preloadAudio('songs/tp_song.mp3');
                
                // Iniciar m√∫sica de fundo
                console.log('üéµ Iniciando m√∫sica de fundo...');
                window.audioManager.startBackgroundMusic();
                
                // Inicializar √°udio da √°rea atual se dispon√≠vel
                if (gameClient && gameClient.areaManager) {
                    console.log('üéµ Inicializando √°udio da √°rea...');
                    gameClient.areaManager.initializeAreaAudio();
                }
            }).catch(e => {
                console.log('‚ö†Ô∏è Ainda n√£o foi poss√≠vel desbloquear o √°udio:', e);
            });
        }
        
        // Inicializa√ß√£o do jogo
        let gameClient = null;

        // Inicializar jogo
        async function initGame() {
            try {
                // Configurar canvas com tamanho fixo
                setupFixedCanvas();
                
                gameClient = new GameClient();
                await gameClient.init('gameCanvas');  // Inicializar gameClient primeiro
                
                // Inicializar sistema de componentes
                window.gameCore = new GameCore();
                await gameCore.init('gameCanvas');
                
                // Integrar com o sistema legado
                gameCore.integrateWithLegacySystem(gameClient);
                
                // Inicializar sistema de intera√ß√£o com mouse (agora que gameClient.canvas existe)
                gameClient.mouseManager = new MouseInteractionManager(gameClient);
                
                // Inicializar joystick virtual para dispositivos m√≥veis
                gameClient.virtualJoystick = new VirtualJoystick();
                
                // O joystick virtual agora ser√° integrado diretamente no update do player
                // N√£o precisamos mais de callbacks aqui - o gameClient vai acessar os dados diretamente
                
                // Tornar joystick dispon√≠vel globalmente para debug
                window.virtualJoystick = gameClient.virtualJoystick;
                
                // Ponto de intera√ß√£o na √°rea "up" - posi√ß√£o fixa no centro
                const interactionWidth = 76.9;  // mant√©m o mesmo tamanho
                const interactionHeight = 50.5; // mant√©m o mesmo tamanho
                
                // Coordenadas fixas baseadas no tamanho do canvas (800x600)
                const interactionX = (800 / 2) - (interactionWidth / 2);   // centralizado horizontalmente (400 - 38.45 = 361.55)
                const interactionY = (600 / 2) - (interactionHeight / 2);  // centralizado verticalmente (300 - 25.25 = 274.75)
                
                gameClient.mouseManager.addInteractionPoint(
                    interactionX,        // x
                    interactionY,        // y
                    interactionWidth,    // width
                    interactionHeight,   // height
                    () => {
                        // Fun√ß√£o vazia - intera√ß√£o com clique removida
                        // S√≥ funciona atrav√©s da colis√£o do player
                    },
                    'area_up_interaction',
                    'up' // NOVA: Especifica que esta intera√ß√£o s√≥ funciona na √°rea "up"
                );
                
                // Fun√ß√£o helper para facilitar cria√ß√£o de pontos de intera√ß√£o
                window.addInteractionPoint = (x, y, width, height, action, id, requiredArea = null) => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.addInteractionPoint(x, y, width, height, action, id, requiredArea);
                    }
                };
                
                window.removeInteractionPoint = (id) => {
                    if (gameClient && gameClient.mouseManager) {
                        gameClient.mouseManager.removeInteractionPoint(id);
                    }
                };
                
                // Helper para obter posi√ß√£o do mouse facilmente
                window.getMousePos = () => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.currentMousePos;
                    }
                    return { x: -1, y: -1 };
                };
                
                // Inicializar m√∫sica de fundo da √°rea inicial
                setTimeout(() => {
                    if (gameClient.areaManager) {
                        gameClient.areaManager.initializeAreaAudio();
                    }
                }, 500); // Pequeno delay para garantir que tudo esteja carregado
                
                
                // Canvas tem tamanho fixo - n√£o precisa de redimensionamento
                // window.addEventListener('resize', () => { ... }); // Removido
                
                // Iniciar game loop
                startGameLoop();
                
                console.log('üéÆ Blog interativo inicializado com sucesso!');
                
                // ===== CONEX√ÉO AUTOM√ÅTICA AO SERVIDOR =====
                console.log('üîó Iniciando conex√£o autom√°tica...');
                showConnectionStatus('üîÑ Conectando ao servidor...', true);
                
                try {
                    await gameClient.connect('Player');
                    console.log('‚úÖ Conectado automaticamente ao servidor multiplayer!');
                    showConnectionStatus('‚úÖ Conectado!', false);
                } catch (error) {
                    console.log('‚ö†Ô∏è Falha na conex√£o autom√°tica, continuando em modo singleplayer:', error.message);
                    showConnectionStatus('‚ö†Ô∏è Modo offline', false);
                    // N√£o √© um erro cr√≠tico - o jogo continua funcionando offline
                }
                
        // Configurar canvas com tamanho fixo
        function setupFixedCanvas() {
            const canvas = document.getElementById('gameCanvas');
            
            // Definir dimens√µes fixas (800x600 √© um bom tamanho para jogos retr√¥)
            const FIXED_WIDTH = 800;
            const FIXED_HEIGHT = 600;
            
            // Definir dimens√µes do canvas
            canvas.width = FIXED_WIDTH;
            canvas.height = FIXED_HEIGHT;
            
            console.log(`Canvas configurado com tamanho fixo: ${canvas.width}x${canvas.height}`);
            
            // Salvar dimens√µes como constantes globais para f√°cil acesso
            window.GAME_WIDTH = FIXED_WIDTH;
            window.GAME_HEIGHT = FIXED_HEIGHT;
        }
                
        } catch (error) {
            console.error('‚ùå Erro ao inicializar:', error);
        }
    }
        
    // ===== FUN√á√ïES DE UTILITY =====
    
    // Mostrar status de conex√£o
    function showConnectionStatus(message, show = true) {
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.style.display = show ? 'block' : 'none';
            
            // Auto-hide depois de 5 segundos se n√£o for um status de loading
            if (show && !message.includes('üîÑ')) {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 5000);
            }
        }
    }
    
    // Atualizar status de retry
    function updateRetryStatus(attempt, maxAttempts, url, delay = 0) {
        const isRender = url.includes('render.com');
        const serverType = isRender ? 'Render' : 'servidor';
        
        if (delay > 0) {
            showConnectionStatus(`‚è≥ Aguardando ${Math.round(delay/1000)}s para retry ${attempt}/${maxAttempts} (${serverType})`, true);
        } else {
            showConnectionStatus(`üîÑ Tentativa ${attempt}/${maxAttempts} - ${serverType}${isRender ? ' (pode estar em sleep)' : ''}`, true);
        }
    }

    // Game loop
        let lastTime = 0;
        function startGameLoop() {
            function gameLoop(currentTime) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                if (gameClient) {
                    gameClient.update(deltaTime);
                    gameClient.render();
                }

                requestAnimationFrame(gameLoop);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Fun√ß√£o para obter coordenadas do mouse em rela√ß√£o a uma div/element
        function getMousePosition(event, element) {
            const rect = element.getBoundingClientRect();
            const scaleX = element.width / rect.width;   // Escala X do canvas
            const scaleY = element.height / rect.height; // Escala Y do canvas
            
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY,
                // Coordenadas brutas (sem escala) caso precise
                rawX: event.clientX - rect.left,
                rawY: event.clientY - rect.top,
                // Informa√ß√µes da div
                elementRect: rect
            };
        }

        // Sistema de pontos de intera√ß√£o via mouse
        class MouseInteractionManager {
            constructor(gameClient) {
                this.gameClient = gameClient;
                this.canvas = gameClient.canvas;
                this.interactionPoints = [];
                this.isMouseDown = false;
                this.currentMousePos = { x: 0, y: 0 };
                
                this.setupMouseEvents();
                console.log('üñ±Ô∏è MouseInteractionManager inicializado');
            }

            setupMouseEvents() {
                // Rastrear movimento do mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    this.currentMousePos = getMousePosition(e, this.canvas);
                    this.checkInteractions();
                });

                // Clique do mouse
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    const mousePos = getMousePosition(e, this.canvas);
                    this.handleClick(mousePos);
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    this.isMouseDown = false;
                });

                // Deixar √°rea do canvas
                this.canvas.addEventListener('mouseleave', (e) => {
                    this.currentMousePos = { x: -1, y: -1 };
                });
            }

            // Adicionar ponto de intera√ß√£o
            addInteractionPoint(x, y, width, height, action, id = null, requiredArea = null) {
                const point = {
                    id: id || `point_${this.interactionPoints.length}`,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    action: action,
                    isHovered: false,
                    cooldown: 0,
                    requiredArea: requiredArea, // Nova propriedade para especificar √°rea necess√°ria
                    playerInside: false,
                    audioPlayed: false,
                    checkCounter: 0
                };
                
                this.interactionPoints.push(point);
                console.log(`üéØ Ponto de intera√ß√£o adicionado: ${point.id} em (${x}, ${y})${requiredArea ? ` [√Årea: ${requiredArea}]` : ''}`);
                return point;
            }

            // Remover ponto de intera√ß√£o
            removeInteractionPoint(id) {
                this.interactionPoints = this.interactionPoints.filter(point => point.id !== id);
                console.log(`üóëÔ∏è Ponto de intera√ß√£o removido: ${id}`);
            }

            // Verificar se ponto est√° dentro da √°rea
            isPointInside(mousePos, area) {
                return mousePos.x >= area.x && 
                       mousePos.x <= area.x + area.width &&
                       mousePos.y >= area.y && 
                       mousePos.y <= area.y + area.height;
            }

            // Verificar colis√£o entre ret√¢ngulos (player vs √°rea de intera√ß√£o)
            isPlayerColliding(player, area) {
                // Obter dimens√µes reais do player baseado na anima√ß√£o atual
                let playerWidth = player.width || 32;  // valor padr√£o se n√£o definido
                let playerHeight = player.height || 32; // valor padr√£o se n√£o definido
                
                // Tentar obter dimens√µes do sprite atual se dispon√≠vel
                if (player.currentSprite && player.currentSprite.width && player.currentSprite.height) {
                    playerWidth = player.currentSprite.width;
                    playerHeight = player.currentSprite.height;
                } else if (player.spriteManager && player.spriteManager.currentSprite) {
                    // Verificar se h√° informa√ß√µes no sprite manager
                    const currentSprite = player.spriteManager.currentSprite;
                    if (currentSprite.width && currentSprite.height) {
                        playerWidth = currentSprite.width;
                        playerHeight = currentSprite.height;
                    }
                }
                
                // Log das dimens√µes para debug
                if (playerWidth !== 32 || playerHeight !== 32) {
                    console.log(`üéÆ Usando dimens√µes do sprite: ${playerWidth}x${playerHeight}`);
                }
                
                // Detec√ß√£o de colis√£o AABB (Axis-Aligned Bounding Box)
                return player.x < area.x + area.width &&
                       player.x + playerWidth > area.x &&
                       player.y < area.y + area.height &&
                       player.y + playerHeight > area.y;
            }

            // Eventos de hover
            onPointEnter(point) {
                this.canvas.style.cursor = 'pointer';
                console.log(`üéØ Mouse entrou na √°rea: ${point.id}`);
            }

            onPointLeave(point) {
                this.canvas.style.cursor = 'default';
                console.log(`üéØ Mouse saiu da √°rea: ${point.id}`);
            }

            // Manipular clique
            handleClick(mousePos) {
                this.interactionPoints.forEach(point => {
                    if (this.isPointInside(mousePos, point) && point.cooldown === 0) {
                        console.log(`üñ±Ô∏è Clique em: ${point.id} na posi√ß√£o (${mousePos.x.toFixed(1)}, ${mousePos.y.toFixed(1)})`);
                        
                        // Executar a√ß√£o
                        if (typeof point.action === 'function') {
                            point.action(mousePos, point);
                        }
                        
                        // Cooldown para evitar spam
                        point.cooldown = 30; // ~0.5 segundos
                    }
                });
            }

            // Renderizar √°reas de debug
            renderDebugAreas(ctx) {
                if (!this.gameClient.debug.enabled) return;

                ctx.save();
                
                // Obter √°rea atual
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                this.interactionPoints.forEach(point => {
                    // S√≥ renderizar area_up_interaction quando estiver na √°rea 'up'
                    if (point.id === 'area_up_interaction' && currentArea !== 'up') {
                        return; // Pula a renderiza√ß√£o desta intera√ß√£o
                    }
                    
                    // √Årea de intera√ß√£o
                    ctx.strokeStyle = point.isHovered ? '#00FF00' : '#FF6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(point.x, point.y, point.width, point.height);
                    
                    // Label
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.fillText(point.id, point.x, point.y - 5);
                    
                    // Highlight se estiver hovering
                    if (point.isHovered) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                        ctx.fillRect(point.x, point.y, point.width, point.height);
                    }
                });

                // Mostrar posi√ß√£o atual do mouse
                if (this.currentMousePos.x >= 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(this.currentMousePos.x, this.currentMousePos.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Coordenadas
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '10px Arial';
                    ctx.fillText(`(${this.currentMousePos.x.toFixed(0)}, ${this.currentMousePos.y.toFixed(0)})`, 
                                this.currentMousePos.x + 5, this.currentMousePos.y - 5);
                }
                
                ctx.restore();
            }

            // Atualizar visibilidade das intera√ß√µes baseada na √°rea atual
            updateInteractionsForArea(currentArea) {
                this.interactionPoints.forEach(point => {
                    // Intera√ß√£o area_up_interaction s√≥ funciona na √°rea "up"
                    if (point.id === 'area_up_interaction') {
                        point.visible = (currentArea === 'up');
                        if (!point.visible) {
                            point.isHovered = false; // Reset hover se n√£o estiver vis√≠vel
                        }
                    }
                });
            }

            // Verificar intera√ß√µes - otimizado por √°rea
            checkInteractions() {
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                // Cache do player para evitar m√∫ltiplas buscas (s√≥ se necess√°rio)
                let playerCached = false;
                
                this.interactionPoints.forEach(point => {
                    // OTIMIZA√á√ÉO PRINCIPAL: S√≥ processar intera√ß√µes da √°rea atual
                    if (point.requiredArea && point.requiredArea !== currentArea) {
                        // Reset estado se n√£o estiver na √°rea correta
                        if (point.isHovered) point.isHovered = false;
                        if (point.playerInside) {
                            point.playerInside = false;
                            point.audioPlayed = false; // Reset √°udio ao sair da √°rea
                        }
                        return; // Skip processamento - ECONOMIA MASSIVA DE CPU
                    }

                    // Verifica√ß√£o de cooldown
                    if (point.cooldown > 0) {
                        point.cooldown--;
                    }

                    // Verifica√ß√£o de mouse (sempre ativa)
                    const wasHovered = point.isHovered;
                    point.isHovered = this.isPointInside(this.currentMousePos, point);

                    // Eventos de mouse
                    if (point.isHovered && !wasHovered) {
                        this.onPointEnter(point);
                    }
                    
                    if (!point.isHovered && wasHovered) {
                        this.onPointLeave(point);
                    }

                    // Verifica√ß√£o de personagem (s√≥ para intera√ß√µes espec√≠ficas e na √°rea correta)
                    if (point.id === 'area_up_interaction' && currentArea === 'up') {
                        // Cache player apenas quando necess√°rio
                        if (!playerCached) {
                            if (!this.cachedPlayer || this.playerCacheTime < Date.now() - 100) {
                                this.cachedPlayer = this.findPlayer();
                                this.playerCacheTime = Date.now();
                            }
                            playerCached = true;
                        }
                        
                        if (this.cachedPlayer) {
                            this.checkPlayerInInteractionAreaOptimized(point);
                        }
                    }
                });
            }

            // Buscar player com fallbacks
            findPlayer() {
                let player = this.gameClient.player;
                
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                return player;
            }

            // Vers√£o otimizada da verifica√ß√£o do personagem
            checkPlayerInInteractionAreaOptimized(point) {
                const player = this.cachedPlayer;
                if (!player) return;

                // Throttling: s√≥ verificar a cada 5 frames (~83ms a 60fps)
                point.checkCounter = (point.checkCounter || 0) + 1;
                if (point.checkCounter % 5 !== 0) return;

                const wasPlayerInside = point.playerInside || false;
                // NOVA: Usar detec√ß√£o de colis√£o entre ret√¢ngulos ao inv√©s de apenas um ponto
                const isPlayerInside = this.isPlayerColliding(player, point);

                // Personagem entrou na √°rea de intera√ß√£o
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o √°udio j√° foi tocado nesta sess√£o na √°rea
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`üö™ Personagem colidiu com √°rea de teleporte! Player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)}) Dimens√µes: ${player.width || 32}x${player.height || 32}`);
                        
                        // Reproduzir √°udio e redirecionar (redirecionamento est√° na fun√ß√£o playAudioImmediate)
                        this.playAudioImmediate('songs/tp_song.mp3');
                    } else {
                        console.log('üîá √Åudio j√° foi tocado nesta entrada na √°rea');
                    }
                }
                
                // Personagem saiu da √°rea de intera√ß√£o
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do √°udio ao sair
                    console.log('üö∂ Personagem saiu da √°rea de teleporte - √°udio resetado');
                }
            }

            // Reproduzir √°udio de forma mais eficiente
            playAudioImmediate(audioPath) {
                try {
                    console.log(`üéµ Tentando reproduzir √°udio: ${audioPath}`);
                    if (window.audioManager) {
                        // Tentar m√∫ltiplos m√©todos de reprodu√ß√£o para garantir que funcione
                        audioManager.playAudioFast(audioPath);
                        
                        // Fallback: tentar m√©todo padr√£o tamb√©m
                        setTimeout(() => {
                            audioManager.playAudio(audioPath);
                        }, 100);
                        
                        console.log('üéµ Comando de reprodu√ß√£o enviado');
                        
                        // REDIRECIONAMENTO: Se for o som de teleporte, redirecionar ap√≥s delay
                        if (audioPath === 'songs/tp_song.mp3') {
                            setTimeout(() => {
                                console.log('üó°Ô∏è Portal Ativado! Redirecionando para o blog...');
                                window.location.href = 'pages/blog.html';
                            }, 1000); // 1000ms delay para garantir que o √°udio toque
                        }
                    } else {
                        console.error('‚ùå AudioManager n√£o dispon√≠vel');
                    }
                } catch (error) {
                    console.error('‚ùå Erro ao reproduzir √°udio:', error);
                }
            }

            // Verificar se o personagem est√° dentro da √°rea de intera√ß√£o (m√©todo antigo - mantido para compatibilidade)
            checkPlayerInInteractionArea(point) {
                // Tentar m√∫ltiplas formas de acessar o player
                let player = this.gameClient.player;
                
                // Se n√£o encontrar, tentar pelo gameCore
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                // Se ainda n√£o encontrar, tentar pelo frameBasedGame
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                if (!player) {
                    console.log('üö´ Player n√£o encontrado - verificando √°rea s√≥ com mouse');
                    return;
                }

                const wasPlayerInside = point.playerInside || false;
                // NOVA: Usar detec√ß√£o de colis√£o entre ret√¢ngulos ao inv√©s de apenas um ponto
                const isPlayerInside = this.isPlayerColliding(player, point);

                // Personagem entrou na √°rea de intera√ß√£o
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o √°udio j√° foi tocado nesta sess√£o na √°rea
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`üö™ Personagem colidiu com √°rea de teleporte! Player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)}) Dimens√µes: ${player.width || 32}x${player.height || 32}`);
                        
                        // Reproduzir √°udio e redirecionar
                        if (window.audioManager) {
                            audioManager.playAudio('songs/tp_song.mp3');
                        }
                        
                        console.log('üéµ Portal ativado! Redirecionando para o blog...');
                        
                        // Redirecionar ap√≥s delay para ouvir o √°udio
                        setTimeout(() => {
                            window.location.href = 'pages/blog.html';
                        }, 800); // 800ms delay para ouvir o som completo
                    } else {
                        console.log('üîá √Åudio j√° foi tocado nesta entrada na √°rea');
                    }
                }
                
                // Personagem saiu da √°rea de intera√ß√£o
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do √°udio ao sair
                    console.log('üö∂ Personagem saiu da √°rea de teleporte - √°udio resetado');
                }
            }
        }

        // Teclas especiais
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                // Toggle debug de colis√µes
                if (window.gameCore) {
                    gameCore.collisionManager.debugMode = !gameCore.collisionManager.debugMode;
                    console.log('üêõ Debug de colis√µes:', gameCore.collisionManager.debugMode);
                }
            }
            
            if (e.key === 'F2') {
                // Toggle debug de intera√ß√µes
                if (window.gameCore) {
                    gameCore.interactionManager.debugMode = !gameCore.interactionManager.debugMode;
                    console.log('üêõ Debug de intera√ß√µes:', gameCore.interactionManager.debugMode);
                }
            }
            
            if (e.key === 'F3') {
                // Reset posi√ß√£o do player
                if (gameClient && gameClient.player) {
                    gameClient.player.x = 400;
                    gameClient.player.y = 300;
                    console.log('üîÑ Posi√ß√£o resetada');
                }
            }
            
            if (e.key === 'F4') {
                // Reconectar ao servidor
                if (gameClient) {
                    console.log('üîÑ Tentando reconectar...');
                    if (gameClient.gameState.isConnected) {
                        gameClient.disconnect();
                        setTimeout(() => {
                            gameClient.connect('Player').catch(err => {
                                console.log('‚ùå Falha na reconex√£o:', err.message);
                            });
                        }, 1000);
                    } else {
                        gameClient.connect('Player').catch(err => {
                            console.log('‚ùå Falha na conex√£o:', err.message);
                        });
                    }
                }
            }
        });

        // Bot√£o de teste de conex√£o
        document.addEventListener('DOMContentLoaded', () => {
            const testButton = document.getElementById('testConnection');
            if (testButton) {
                testButton.addEventListener('click', async () => {
                    console.log('üß™ Iniciando teste de conex√£o...');
                    testButton.textContent = 'üîÑ Testando...';
                    testButton.disabled = true;
                    
                    try {
                        const networkManager = new NetworkManager();
                        await networkManager.connect({
                            name: 'TestPlayer',
                            color: '#00FF00'
                        });
                        
                        console.log('‚úÖ Teste de conex√£o bem-sucedido!');
                        testButton.textContent = '‚úÖ Conectado!';
                        testButton.style.background = '#4CAF50';
                        
                        // Desconectar ap√≥s teste
                        setTimeout(() => {
                            networkManager.disconnect();
                            testButton.textContent = 'üîó Testar Conex√£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                        
                    } catch (error) {
                        console.error('‚ùå Teste de conex√£o falhou:', error);
                        testButton.textContent = '‚ùå Falhou';
                        testButton.style.background = '#f44336';
                        
                        setTimeout(() => {
                            testButton.textContent = 'üîó Testar Conex√£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                    }
                });
            }
        });

        // Inicializar quando a p√°gina carregar
        window.addEventListener('load', initGame);
    </script>

</body>
</html>