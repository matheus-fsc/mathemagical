<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
2    <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: ws: wss: https: 'unsafe-inline'; connect-src 'self' ws: wss: https: data: blob:;">
    <title> ??? </title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="favicon.ico">
    
    <!-- Fixed Size Canvas Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            display: block;
            width: 800px;  /* Tamanho fixo para todos os dispositivos */
            height: 600px; /* Tamanho fixo para todos os dispositivos */
            background: #000;
            border: 2px solid #333;
            image-rendering: pixelated; /* Para manter sprites n√≠tidos */
        }
        
        /* Responsivo para centralizar em telas pequenas */
        @media (max-width: 800px), (max-height: 600px) {
            body {
                padding: 0;
                margin: 0;
                overflow: hidden; /* Evitar scroll */
            }
            
            #gameCanvas {
                /* Manter tamanho fixo mas centralizar */
                display: block;
                margin: 0 auto;
                border: 1px solid #333; /* Borda menor para mobile */
            }
        }
        
        .debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 12px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
            display: none;
        }
        
        /* ===== VIRTUAL JOYSTICK STYLES ===== */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none; /* Oculto por padr√£o, mostrado apenas em mobile */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .config-section::before {
            content: '‚ñ∫';
            position: absolute;
            left: -15px;
            top: 15px;
            color: #00ff00;
            font-size: 16px;
        }
        
        .config-label {
            display: block;
            font-size: 16px;
            color: #00ff00;
            margin-bottom: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .config-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #00ffff;
            border-radius: 0;
            background: rgba(0, 20, 40, 0.8);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            transition: all 0.3s ease;
            clip-path: polygon(0 0, calc(100% - 10px) 0, 100% 10px, 100% 100%, 0 100%);
            position: relative;
            z-index: 1000;
            pointer-events: auto;
        }
        
        .config-input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 
                0 0 10px #00ff00,
                inset 0 0 10px rgba(0, 255, 0, 0.1);
            background: rgba(0, 30, 60, 0.9);
        }
        
        .config-input::placeholder {
            color: rgba(0, 255, 255, 0.5);
            font-style: italic;
        }
        
        /* Y2K Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
            background: rgba(0, 30, 60, 0.3);
            padding: 10px;
            border: 1px solid #00ffff;
        }
        
        .toggle-label {
            font-size: 16px;
            color: #00ff00;
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .toggle-switch {
            position: relative;
            width: 80px;
            height: 30px;
            appearance: none;
            background: linear-gradient(45deg, #001122, #002244);
            border: 2px solid #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            clip-path: polygon(5px 0, 100% 0, 100% calc(100% - 5px), calc(100% - 5px) 100%, 0 100%, 0 5px);
        }
        
        .toggle-switch:checked {
            background: linear-gradient(45deg, #002200, #004400);
            border-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }
        
        .toggle-switch::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            transition: all 0.3s ease;
            clip-path: polygon(0 0, calc(100% - 3px) 0, 100% 3px, 100% 100%, 3px 100%, 0 calc(100% - 3px));
        }
        
        .toggle-switch:checked::before {
            transform: translateX(48px);
            background: linear-gradient(45deg, #00ff00, #88ff00);
        }
        
        .toggle-status {
            font-size: 14px;
            color: #00ffff;
            font-weight: bold;
            min-width: 100px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .start-game-button {
            background: linear-gradient(45deg, #001122, #003366, #001122);
            color: #00ffff;
            padding: 18px 40px;
            border: 3px solid #00ffff;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            position: relative;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        
        .start-game-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .start-game-button:hover {
            background: linear-gradient(45deg, #003366, #0066cc, #003366);
            border-color: #00ff00;
            box-shadow: 
                0 0 20px #00ff00,
                inset 0 0 20px rgba(0, 255, 0, 0.1);
            transform: translateY(-2px);
            text-shadow: 0 0 10px #00ffff;
        }
        
        .start-game-button:hover::before {
            opacity: 1;
        }
        
        .config-description {
            font-size: 14px;
            color: #00ff00;
            margin-bottom: 25px;
            line-height: 1.6;
            text-align: center;
            font-style: italic;
            padding: 10px;
            border: 1px dashed #00ffff;
            background: rgba(0, 255, 255, 0.05);
        }
        
        /* ===== RESPONSIVIDADE Y2K SCI-FI ===== */
        
        /* Tablets Portrait */
        @media (max-width: 768px) {
            .game-config-content {
                padding: 30px 20px;
                max-width: 90%;
                margin: 20px;
            }
            
            .game-config-title {
                font-size: 24px;
                letter-spacing: 2px;
            }
            
            .config-input {
                font-size: 14px;
                padding: 10px;
            }
            
            .start-game-button {
                padding: 15px 25px;
                font-size: 16px;
                letter-spacing: 1px;
            }
            
            .toggle-switch {
                width: 70px;
                height: 28px;
            }
            
            .toggle-switch::before {
                width: 20px;
                height: 20px;
                top: 2px;
                left: 2px;
            }
            
            .toggle-switch:checked::before {
                transform: translateX(42px);
            }
        }
        
        /* Mobile Portrait */
        @media (max-width: 480px) {
            .game-config-modal {
                padding: 10px;
                align-items: flex-start;
                padding-top: 50px;
            }
            
            .game-config-content {
                padding: 25px 15px;
                max-width: 95%;
                margin: 10px;
                clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px));
            }
            
            .game-config-content::before {
                clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px));
            }
            
            .game-config-title {
                font-size: 20px;
                letter-spacing: 1px;
                margin-bottom: 15px;
            }
            
            .game-config-title::after {
                content: '‚óä‚óä‚óä‚óä‚óä‚óä‚óä‚óä‚óä‚óä';
                font-size: 10px;
                margin-top: 8px;
            }
            
            .config-description {
                font-size: 12px;
                padding: 8px;
                margin-bottom: 20px;
            }
            
            .config-section {
                margin: 20px 0;
                padding: 12px;
            }
            
            .config-label {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            .config-input {
                font-size: 14px;
                padding: 10px;
                clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 0 100%);
            }
            
            .toggle-container {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
                padding: 8px;
            }
            
            .toggle-label {
                font-size: 14px;
            }
            
            .toggle-switch {
                width: 60px;
                height: 26px;
                align-self: center;
            }
            
            .toggle-switch::before {
                width: 18px;
                height: 18px;
                top: 2px;
                left: 2px;
            }
            
            .toggle-switch:checked::before {
                transform: translateX(34px);
            }
            
            .toggle-status {
                font-size: 12px;
                text-align: center;
                min-width: auto;
            }
            
            .start-game-button {
                padding: 12px 20px;
                font-size: 14px;
                letter-spacing: 1px;
                margin-top: 20px;
                clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
            }
        }
        
        /* Mobile Landscape */
        @media (max-width: 768px) and (orientation: landscape) {
            .game-config-modal {
                padding: 20px 10px;
                align-items: center;
            }
            
            .game-config-content {
                max-width: 80%;
                padding: 20px;
            }
            
            .game-config-title {
                font-size: 22px;
                margin-bottom: 10px;
            }
            
            .config-description {
                font-size: 12px;
                margin-bottom: 15px;
            }
            
            .config-section {
                margin: 15px 0;
                padding: 10px;
            }
        }
        
        /* Very Small Screens */
        @media (max-width: 320px) {
            .game-config-content {
                padding: 20px 10px;
            }
            
            .game-config-title {
                font-size: 18px;
                letter-spacing: 0.5px;
            }
            
            .config-input {
                font-size: 13px;
                padding: 8px;
            }
            
            .start-game-button {
                padding: 10px 15px;
                font-size: 13px;
            }
        }
        
        /* High DPI Displays */
        @media (-webkit-min-device-pixel-ratio: 2) {
            .game-config-content {
                border-width: 1px;
            }
            
            .config-input {
                border-width: 1px;
            }
            
            .toggle-switch {
                border-width: 1px;
            }
        }
        
        /* ===== VIRTUAL JOYSTICK STYLES ===== */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none; /* Oculto por padr√£o - controlado via JavaScript */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(27, 86, 128, 0.4);
            border: 3px solid rgb(17, 76, 122);
            position: relative;
            box-shadow: 
                0 0 20px rgba(8, 34, 76, 0.6),
                inset 0 0 20px rgba(26, 66, 107, 0.3);
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            
            /* Indicador central sutil */
            &::before {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: rgba(26, 66, 107, 0.6);
                transform: translate(-50%, -50%);
            }
        }
        
        .joystick-base:active {
            transform: scale(1.05);
            border-color: rgb(26, 66, 107);
            box-shadow: 
                0 0 30px rgba(27, 86, 128, 0.5),
                inset 0 0 20px rgba(26, 66, 107, 0.4);
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #1b5680, #0B2B57);
            border: 2px solid rgb(17, 76, 122);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 15px rgb(8, 34, 76), inset 0 2px 5px rgb(26, 66, 107);
            transition: all 0.1s ease;
            cursor: pointer;
            
            /* Highlight central */
            &::before {
                content: '';
                position: absolute;
                top: 20%;
                left: 30%;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.6);
                filter: blur(1px);
            }
        }
        
        .joystick-knob:active {
            background: radial-gradient(circle at 30% 30%, #26608B, #1b5680);
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        /* Responsive para diferentes tamanhos de tela mobile */
        @media (max-width: 480px) {
            .virtual-joystick {
                bottom: 20px;
                left: 20px;
            }
            
            .joystick-base {
                width: 100px;
                height: 100px;
            }
            
            .joystick-knob {
                width: 40px;
                height: 40px;
            }
        }
        
        @media (max-height: 600px) {
            .virtual-joystick {
                bottom: 15px;
                left: 15px;
            }
            
            .joystick-base {
                width: 90px;
                height: 90px;
            }
            
            .joystick-knob {
                width: 35px;
                height: 35px;
            }
        }
        
        /* Orienta√ß√£o landscape em mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .virtual-joystick {
                bottom: 10px;
                left: 15px;
                transform: scale(0.8);
            }
        }
        
        /* Dispositivos com notch */
        @supports (padding: max(0px)) {
            .virtual-joystick {
                bottom: max(30px, env(safe-area-inset-bottom));
                left: max(30px, env(safe-area-inset-left));
            }
        }
    </style>
</head>
<body>
    <!-- Fullscreen Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Mobile Virtual Joystick -->
    <div class="virtual-joystick" id="virtualJoystick">
        <div class="joystick-base" id="joystickBase">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>
    
    <!-- Audio Status Indicator -->
    <div id="audioIndicator" style="
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ffff;
        padding: 10px 15px;
        border-radius: 5px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        z-index: 2000;
        border: 1px solid #00ffff;
        display: none;
    ">
        üéµ Clique para ativar √°udio
    </div>
    
    <!-- Debug Info (Hidden by default) -->
    <div class="debug-info" id="debugInfo">
        Debug Mode: ON
    </div>

  <!-- Game Scripts -->
<script src="socket.io.min.js?v=1.0.0"></script>
<script>
  // Debug: Verificar se Socket.io foi carregado
  console.log('üîç Socket.io dispon√≠vel:', typeof io !== 'undefined' ? '‚úÖ SIM' : '‚ùå N√ÉO');
  if (typeof io !== 'undefined') {
    console.log('üì¶ Socket.io version:', io.version || 'unknown');
  }
</script>
<script src="config/serverConfig.js"></script>
<script src="legacy/areaManager.js"></script>
<script src="input/inputManager.js"></script>
<script src="sprites/frameBasedSpriteManager.js"></script>
<script src="legacy/frameBasedPlayer.js"></script>
<script src="network/mockServer.js"></script>
<script>
  // Debug: Verificar se MockServer foi carregado
  console.log('ü§ñ MockServer dispon√≠vel:', typeof MockServer !== 'undefined' ? '‚úÖ SIM' : '‚ùå N√ÉO');
</script>
<script src="network/networkManager.js"></script>
<script src="network/multiplayerManager.js"></script>

<!-- Component System -->
<script src="managers/AssetLoader.js"></script>
<script src="managers/SceneManager.js"></script>
<script src="managers/CollisionManager.js"></script>
<script src="managers/InteractionManager.js"></script>
<script src="components/GameCore.js"></script>

<script src="core/gameClient.js"></script>

    <script>
        // ===== SISTEMA DE PERMISS√ÉO DE √ÅUDIO =====
        let audioEnabled = false;
        
        // Sistema de √°udio global e simples
        window.audioManager = {
            audioCache: new Map(),
            currentBackgroundMusic: null,
            isBackgroundPlaying: false,
            
            preloadAudio(src) {
                if (!this.audioCache.has(src)) {
                    const audio = new Audio(src);
                    audio.preload = 'auto';
                    audio.volume = 0.5;
                    audio.load();
                    this.audioCache.set(src, audio);
                    console.log('üéµ √Åudio pr√©-carregado:', src);
                }
                return this.audioCache.get(src);
            },
            
            startBackgroundMusic(src = 'songs/backgroundsond.mp3', volume = 0.3) {
                if (!audioEnabled) {
                    console.log('üîá √Åudio n√£o habilitado - m√∫sica de fundo n√£o iniciada');
                    return;
                }
                
                try {
                    this.stopBackgroundMusic();
                    const audio = this.preloadAudio(src);
                    audio.loop = true;
                    audio.volume = volume;
                    
                    audio.play().then(() => {
                        this.currentBackgroundMusic = audio;
                        this.isBackgroundPlaying = true;
                        console.log('üéµ M√∫sica de fundo iniciada:', src);
                    }).catch(error => {
                        console.warn('‚ö†Ô∏è Erro ao tocar m√∫sica de fundo:', error);
                    });
                } catch (error) {
                    console.error('‚ùå Erro no sistema de √°udio:', error);
                }
            },
            
            stopBackgroundMusic() {
                if (this.currentBackgroundMusic) {
                    this.currentBackgroundMusic.pause();
                    this.currentBackgroundMusic.currentTime = 0;
                    this.currentBackgroundMusic = null;
                    this.isBackgroundPlaying = false;
                }
            },
            
            playAudioFast(src = 'songs/tp_song.mp3') {
                if (!audioEnabled) {
                    console.log('üîá √Åudio n√£o habilitado - efeito sonoro n√£o reproduzido');
                    return;
                }
                
                try {
                    const audio = this.preloadAudio(src);
                    audio.currentTime = 0;
                    audio.play().then(() => {
                        console.log('üéµ Efeito sonoro reproduzido:', src);
                    }).catch(e => {
                        console.warn('‚ö†Ô∏è Erro ao reproduzir efeito sonoro:', e);
                    });
                } catch (error) {
                    console.error('‚ùå Erro ao reproduzir √°udio:', error);
                }
            },
            
            playAudio(src = 'songs/tp_song.mp3') {
                this.playAudioFast(src);
            }
        };
        
        // ===== VIRTUAL JOYSTICK CLASS =====
        class VirtualJoystick {
            constructor() {
                this.joystickElement = document.getElementById('virtualJoystick');
                this.baseElement = document.getElementById('joystickBase');
                this.knobElement = document.getElementById('joystickKnob');
                
                this.isActive = false;
                this.startPos = { x: 0, y: 0 };
                this.currentPos = { x: 0, y: 0 };
                this.direction = { x: 0, y: 0 }; // Valores normalizados entre -1 e 1
                this.magnitude = 0; // Intensidade do movimento (0 a 1)
                
                this.baseRadius = 60; // Raio da base do joystick
                this.knobRadius = 25; // Raio do knob
                this.maxDistance = this.baseRadius - this.knobRadius; // Dist√¢ncia m√°xima do knob do centro
                
                this.onMoveCallback = null;
                this.onStartCallback = null;
                this.onEndCallback = null;
                
                this.setupEvents();
                this.detectMobileDevice();
                
                console.log('üïπÔ∏è VirtualJoystick inicializado');
            }
            
            detectMobileDevice() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                                 'ontouchstart' in window ||
                                 navigator.maxTouchPoints > 0;
                
                // DEBUG: For√ßar exibi√ß√£o para testar
                const forceShow = true;
                
                if (isMobile || forceShow) {
                    this.joystickElement.style.display = 'block';
                    this.joystickElement.style.pointerEvents = 'auto';
                    console.log('üì± Joystick virtual habilitado (mobile:', isMobile, 'force:', forceShow, ')');
                } else {
                    this.joystickElement.style.display = 'none';
                    console.log('üñ•Ô∏è Dispositivo desktop detectado - joystick virtual desabilitado');
                }
                
                return isMobile || forceShow;
            }
            
            setupEvents() {
                // Sistema simples e direto - sem flags complexas
                this.baseElement.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.startInput(e);
                });
                
                this.baseElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startInput(e);
                }, { passive: false });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isActive) this.moveInput(e);
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (this.isActive) this.moveInput(e);
                }, { passive: false });
                
                document.addEventListener('mouseup', (e) => {
                    if (this.isActive) this.endInput(e);
                });
                
                document.addEventListener('touchend', (e) => {
                    if (this.isActive) this.endInput(e);
                }, { passive: false });
                
                // Prevenir comportamentos padr√£o
                this.baseElement.addEventListener('dragstart', (e) => e.preventDefault());
                this.baseElement.addEventListener('selectstart', (e) => e.preventDefault());
                this.baseElement.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            startInput(event) {
                if (this.isActive) {
                    console.log('‚ùå Tentativa de ativa√ß√£o dupla ignorada');
                    return;
                }
                
                console.log('üü¢ Iniciando joystick...');
                this.isActive = true;
                const touch = event.touches ? event.touches[0] : event;
                const rect = this.baseElement.getBoundingClientRect();
                
                this.startPos = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                
                this.currentPos = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                
                this.updateKnobPosition();
                console.log('üïπÔ∏è Joystick ATIVADO - magnitude:', this.magnitude.toFixed(2), 'direction:', this.direction);
            }
            
            moveInput(event) {
                if (!this.isActive) {
                    console.log('‚ùå Movimento ignorado - joystick inativo');
                    return;
                }
                
                const touch = event.touches ? event.touches[0] : event;
                
                this.currentPos = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                
                this.updateKnobPosition();
                
                if (this.magnitude > 0.1) {
                    console.log('üïπÔ∏è MOVIMENTO - magnitude:', this.magnitude.toFixed(2), 'direction:', 
                        { x: this.direction.x.toFixed(2), y: this.direction.y.toFixed(2) });
                }
            }
            
            endInput(event) {
                if (!this.isActive) {
                    console.log('‚ùå Tentativa de desativa√ß√£o ignorada - j√° inativo');
                    return;
                }
                
                console.log('üî¥ Desativando joystick...');
                this.isActive = false;
                this.direction = { x: 0, y: 0 };
                this.magnitude = 0;
                this.knobElement.style.transform = 'translate(-50%, -50%)';
                
                console.log('üïπÔ∏è Joystick DESATIVADO');
            }
            
            // M√©todo para for√ßar finaliza√ß√£o em casos de emerg√™ncia
            forceEnd() {
                if (this.isActive) {
                    this.isActive = false;
                    this.isDragging = false;
                    this.eventType = null;
                    
                    // Retornar knob para o centro
                    this.direction = { x: 0, y: 0 };
                    this.magnitude = 0;
                    this.knobElement.style.transform = 'translate(-50%, -50%)';
                    
                    if (this.onEndCallback) {
                        this.onEndCallback(this.direction, this.magnitude);
                    }
                    
                    console.log('üïπÔ∏è Joystick for√ßadamente desativado');
                }
            }
            
            updateKnobPosition() {
                const deltaX = this.currentPos.x - this.startPos.x;
                const deltaY = this.currentPos.y - this.startPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Limitar movimento do knob dentro da base
                const clampedDistance = Math.min(distance, this.maxDistance);
                const angle = Math.atan2(deltaY, deltaX);
                
                const knobX = Math.cos(angle) * clampedDistance;
                const knobY = Math.sin(angle) * clampedDistance;
                
                // Atualizar posi√ß√£o visual do knob
                this.knobElement.style.transform = `translate(-50%, -50%) translate(${knobX}px, ${knobY}px)`;
                
                // Calcular dire√ß√£o normalizada (-1 a 1)
                this.direction = {
                    x: clampedDistance > 0 ? knobX / this.maxDistance : 0,
                    y: clampedDistance > 0 ? knobY / this.maxDistance : 0
                };
                
                // Calcular magnitude (0 a 1)
                this.magnitude = clampedDistance / this.maxDistance;
            }
            
            // M√©todos para configurar callbacks
            setOnMove(callback) {
                this.onMoveCallback = callback;
            }
            
            setOnStart(callback) {
                this.onStartCallback = callback;
            }
            
            setOnEnd(callback) {
                this.onEndCallback = callback;
            }
            
            // Getter para verificar se est√° ativo
            get active() {
                return this.isActive;
            }
            
            // Getter para dire√ß√£o atual
            get currentDirection() {
                return { ...this.direction };
            }
            
            // Getter para magnitude atual
            get currentMagnitude() {
                return this.magnitude;
            }
        }
        
        // ===== SISTEMA DE CONFIGURA√á√ÉO DO JOGO =====
        let gameConfig = {
            playerName: '',
            audioEnabled: true // Padr√£o habilitado
        };
        
        // Vari√°vel global para controlar se o √°udio foi desbloqueado
        window.audioUnlocked = false;
        
        // Fun√ß√£o para carregar configura√ß√µes do localStorage vindas da p√°gina de config
        function loadGameConfig() {
            console.log('üîç Iniciando carregamento de configura√ß√µes...');
            console.log('üóÇÔ∏è Verificando localStorage dispon√≠vel:', typeof(Storage) !== "undefined");
            
            try {
                // Listar todas as chaves do localStorage para debug
                console.log('üóÉÔ∏è Chaves dispon√≠veis no localStorage:', Object.keys(localStorage));
                
                const storedConfig = localStorage.getItem('gameConfig');
                console.log('üì• localStorage gameConfig (raw):', storedConfig);
                console.log('üì• Tipo do valor obtido:', typeof storedConfig);
                
                if (storedConfig) {
                    console.log('‚úÖ Configura√ß√£o encontrada no localStorage');
                    
                    const parsedConfig = JSON.parse(storedConfig);
                    console.log('üìã Configura√ß√£o parseada:', parsedConfig);
                    console.log('üîä audioEnabled na config:', parsedConfig.audioEnabled, typeof parsedConfig.audioEnabled);
                    console.log('üë§ playerName na config:', parsedConfig.playerName, typeof parsedConfig.playerName);
                    
                    // Backup das configura√ß√µes antes de mesclar
                    const configBackup = { ...gameConfig };
                    console.log('üíæ Backup das configura√ß√µes padr√£o:', configBackup);
                    
                    gameConfig = { ...gameConfig, ...parsedConfig };
                    console.log('‚öôÔ∏è Configura√ß√µes mescladas:', gameConfig);
                    console.log('üîä gameConfig.audioEnabled final:', gameConfig.audioEnabled, typeof gameConfig.audioEnabled);
                    
                    // Limpar localStorage ap√≥s carregar
                    localStorage.removeItem('gameConfig');
                    console.log('üóëÔ∏è localStorage limpo ap√≥s carregamento');
                    
                    // Verificar se foi realmente removido
                    const verificacaoRemocao = localStorage.getItem('gameConfig');
                    console.log('üîç Verifica√ß√£o p√≥s-remo√ß√£o:', verificacaoRemocao);
                    
                    return true;
                } else {
                    console.log('‚ö†Ô∏è Nenhuma configura√ß√£o encontrada no localStorage');
                }
            } catch (error) {
                console.error('‚ùå Erro ao carregar configura√ß√µes:', error);
                console.error('‚ùå Stack trace:', error.stack);
            }
            
            console.log('‚öôÔ∏è Usando configura√ß√µes padr√£o');
            return false;
        }
        
        // Verificar se deve redirecionar para p√°gina de configura√ß√£o
        function checkConfigRedirect() {
            // Se n√£o tem configura√ß√µes salvas, redirecionar para config.html
            const hasConfig = loadGameConfig();
            if (!hasConfig) {
                console.log('üîÑ Redirecionando para p√°gina de configura√ß√£o...');
                window.location.href = 'config.html';
                return false;
            }
            return true;
        }
        
        // Aplicar configura√ß√µes carregadas
        function applyGameConfig() {
            // Verificar se j√° foi aplicado para evitar loop infinito
            if (window.configAlreadyApplied) {
                console.log('‚ö†Ô∏è Configura√ß√µes j√° aplicadas, evitando loop');
                return;
            }
            
            console.log('üöÄ Aplicando configura√ß√µes do jogo:', gameConfig);
            console.log('üîä Verificando √°udio - audioEnabled:', gameConfig.audioEnabled, typeof gameConfig.audioEnabled);
            
            // Marcar como aplicado
            window.configAlreadyApplied = true;
            
            // Configurar √°udio se habilitado
            if (gameConfig.audioEnabled === true) {
                console.log('‚úÖ √Åudio HABILITADO - chamando enableAudio()');
                enableAudio();
            } else {
                console.log('üîá √Åudio DESABILITADO pelo usu√°rio');
                console.log('üîá Motivo - gameConfig.audioEnabled =', gameConfig.audioEnabled);
                audioEnabled = false;
            }
            
            // Aplicar nome do jogador se o gameClient j√° existir
            if (gameClient) {
                gameClient.gameState.nickname = gameConfig.playerName;
                // Tamb√©m atualizar o player se existir
                if (gameClient.player) {
                    gameClient.player.nickname = gameConfig.playerName;
                }
                console.log(`üë§ Nome do jogador definido: ${gameConfig.playerName}`);
            } else {
                // Se gameClient ainda n√£o existe, salvar para aplicar depois
                console.log(`üë§ Nome ser√° aplicado quando o jogo inicializar: ${gameConfig.playerName}`);
            }
            
            console.log('‚úÖ Configura√ß√µes aplicadas com sucesso!');
        }
        
        // Fun√ß√£o para habilitar √°udio (chamada internamente)
        function enableAudio() {
            console.log('üéµ Habilitando sistema de √°udio...');
            audioEnabled = true;
            
            // Mostrar indicador de √°udio
            const audioIndicator = document.getElementById('audioIndicator');
            if (audioIndicator) {
                audioIndicator.style.display = 'block';
            }
            
            // Criar fun√ß√£o para desbloquear √°udio na primeira intera√ß√£o
            const unlockAudio = () => {
                console.log('üéµ Primeira intera√ß√£o detectada - desbloqueando √°udio...');
                
                // Esconder indicador
                if (audioIndicator) {
                    audioIndicator.style.display = 'none';
                    console.log('üëÅÔ∏è Indicador de √°udio escondido');
                }
                
                // Tocar um som silencioso para desbloquear o contexto de √°udio
                console.log('üîá Criando √°udio de teste silencioso...');
                const testAudio = new Audio('songs/backgroundsond.mp3');
                testAudio.volume = 0.01; // Volume muito baixo ao inv√©s de 0
                testAudio.currentTime = 0;
                
                console.log('‚ñ∂Ô∏è Tentando reproduzir √°udio de teste...');
                testAudio.play().then(() => {
                    console.log('‚úÖ Contexto de √°udio desbloqueado com sucesso!');
                    
                    // Marcar √°udio como desbloqueado globalmente
                    window.audioUnlocked = true;
                    audioEnabled = true; // ‚Üê Crucial: ativar o audioEnabled tamb√©m!
                    console.log('üîì √Åudio globalmente desbloqueado - window.audioUnlocked =', window.audioUnlocked);
                    console.log('üîä audioEnabled definido como:', audioEnabled);
                    
                    // Verificar se audioManager est√° dispon√≠vel
                    console.log('üîç Verificando disponibilidade do audioManager...');
                    if (window.audioManager) {
                        console.log('üéµ AudioManager encontrado - iniciando √°udio...');
                        
                        try {
                            // Pr√©-carregar √°udios cr√≠ticos
                            console.log('üì¶ Pr√©-carregando √°udios...');
                            window.audioManager.preloadAudio('songs/backgroundsond.mp3');
                            window.audioManager.preloadAudio('songs/tp_song.mp3');
                            
                            // Iniciar m√∫sica de fundo
                            console.log('üéµ Iniciando m√∫sica de fundo via AudioManager...');
                            window.audioManager.startBackgroundMusic();
                            
                            // Inicializar √°udio da √°rea atual se dispon√≠vel
                            if (gameClient && gameClient.areaManager) {
                                console.log('üéµ Inicializando √°udio da √°rea atual via AreaManager...');
                                gameClient.areaManager.initializeAreaAudio();
                            }
                        } catch (error) {
                            console.error('‚ùå Erro ao usar AudioManager:', error);
                        }
                    } else {
                        console.log('‚ö†Ô∏è AudioManager n√£o encontrado - aguardando carregamento...');
                        
                        // Aguardar um pouco e tentar novamente
                        setTimeout(() => {
                            if (window.audioManager) {
                                console.log('üéµ AudioManager carregado ap√≥s timeout - iniciando √°udio...');
                                window.audioManager.preloadAudio('songs/backgroundsond.mp3');
                                window.audioManager.preloadAudio('songs/tp_song.mp3');
                                window.audioManager.startBackgroundMusic();
                                
                                if (gameClient && gameClient.areaManager) {
                                    gameClient.areaManager.initializeAreaAudio();
                                }
                            } else {
                                console.log('‚ö†Ô∏è AudioManager ainda n√£o encontrado - tentando m√©todo alternativo...');
                                
                                // M√©todo alternativo: criar e tocar √°udio diretamente
                                const backgroundMusic = new Audio('songs/backgroundsond.mp3');
                                backgroundMusic.loop = true;
                                backgroundMusic.volume = 0.5;
                                
                                backgroundMusic.play().then(() => {
                                    console.log('‚úÖ M√∫sica de fundo iniciada com m√©todo alternativo!');
                                }).catch(error => {
                                    console.log('‚ùå Erro ao tocar m√∫sica de fundo:', error);
                                });
                            }
                        }, 1000);
                    }
                    
                    // Tamb√©m tentar inicializar m√∫sica da √°rea atual se AreaManager j√° existe
                    if (gameClient && gameClient.areaManager) {
                        console.log('üéµ Tentando inicializar m√∫sica da √°rea ap√≥s desbloqueio...');
                        gameClient.areaManager.initializeAreaAudio();
                    }
                    
                    // Remover listeners ap√≥s desbloqueio
                    document.removeEventListener('click', unlockAudio);
                    document.removeEventListener('keydown', unlockAudio);
                    document.removeEventListener('touchstart', unlockAudio);
                    
                }).catch(e => {
                    console.error('‚ùå Erro ao desbloquear √°udio:', e);
                    console.log('üîÑ Tentando m√©todo alternativo de desbloqueio...');
                    
                    // M√©todo alternativo: definir flags mesmo com erro
                    window.audioUnlocked = true;
                    audioEnabled = true;
                    console.log('‚ö° Flags de √°udio definidas mesmo com erro');
                    
                    // Esconder indicador
                    if (audioIndicator) {
                        audioIndicator.style.display = 'none';
                    }
                    
                    // Tentar inicializar AudioManager mesmo assim
                    if (window.audioManager) {
                        console.log('üéµ Tentando AudioManager mesmo com erro...');
                        try {
                            window.audioManager.startBackgroundMusic();
                        } catch (audioError) {
                            console.error('‚ùå Erro no AudioManager:', audioError);
                        }
                    }
                });
            };
            
            // Aguardar primeira intera√ß√£o do usu√°rio para desbloquear √°udio
            document.addEventListener('click', unlockAudio, { once: true });
            document.addEventListener('keydown', unlockAudio, { once: true });
            document.addEventListener('touchstart', unlockAudio, { once: true });
            
            console.log('üéµ Sistema de √°udio configurado - aguardando intera√ß√£o do usu√°rio...');
        }
        
        // Inicializa√ß√£o do jogo
        let gameClient = null;

        // Inicializar jogo
        async function initGame() {
            try {
                // Verificar se j√° foi inicializado
                if (window.gameInitialized) {
                    console.log('‚ö†Ô∏è Jogo j√° inicializado, evitando duplica√ß√£o');
                    return;
                }
                
                // Verificar se deve redirecionar para configura√ß√£o
                if (!checkConfigRedirect()) {
                    return; // P√°gina ser√° redirecionada
                }
                
                // Marcar como inicializado
                window.gameInitialized = true;
                
                // Configurar canvas com tamanho fixo
                setupFixedCanvas();
                
                gameClient = new GameClient();
                await gameClient.init('gameCanvas');  // Inicializar gameClient primeiro
                
                // Aplicar configura√ß√µes carregadas (APENAS UMA VEZ)
                applyGameConfig();
                
                // Aplicar nome do jogador das configura√ß√µes se dispon√≠vel
                if (gameConfig && gameConfig.playerName) {
                    gameClient.gameState.nickname = gameConfig.playerName;
                    console.log(`üë§ Nome do jogador aplicado na inicializa√ß√£o: ${gameConfig.playerName}`);
                }
                
                // Inicializar sistema de componentes
                window.gameCore = new GameCore();
                await gameCore.init('gameCanvas');
                
                // Integrar com o sistema legado
                gameCore.integrateWithLegacySystem(gameClient);
                
                // Inicializar sistema de intera√ß√£o com mouse (agora que gameClient.canvas existe)
                gameClient.mouseManager = new MouseInteractionManager(gameClient);
                
                // Inicializar joystick virtual para dispositivos m√≥veis
                gameClient.virtualJoystick = new VirtualJoystick();
                
                // O joystick virtual agora ser√° integrado diretamente no update do player
                // N√£o precisamos mais de callbacks aqui - o gameClient vai acessar os dados diretamente
                
                // Tornar joystick dispon√≠vel globalmente para debug
                window.virtualJoystick = gameClient.virtualJoystick;
                
                // Ponto de intera√ß√£o na √°rea "up" - posi√ß√£o fixa no centro
                const interactionWidth = 76.9;  // mant√©m o mesmo tamanho
                const interactionHeight = 50.5; // mant√©m o mesmo tamanho
                
                // Coordenadas fixas baseadas no tamanho do canvas (800x600)
                const interactionX = (800 / 2) - (interactionWidth / 2);   // centralizado horizontalmente (400 - 38.45 = 361.55)
                const interactionY = (600 / 2) - (interactionHeight / 2);  // centralizado verticalmente (300 - 25.25 = 274.75)
                
                gameClient.mouseManager.addInteractionPoint(
                    interactionX,        // x
                    interactionY,        // y
                    interactionWidth,    // width
                    interactionHeight,   // height
                    () => {
                        // Fun√ß√£o vazia - intera√ß√£o com clique removida
                        // S√≥ funciona atrav√©s da colis√£o do player
                    },
                    'area_up_interaction',
                    'up' // NOVA: Especifica que esta intera√ß√£o s√≥ funciona na √°rea "up"
                );
                
                // Fun√ß√£o helper para facilitar cria√ß√£o de pontos de intera√ß√£o
                window.addInteractionPoint = (x, y, width, height, action, id, requiredArea = null) => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.addInteractionPoint(x, y, width, height, action, id, requiredArea);
                    }
                };
                
                window.removeInteractionPoint = (id) => {
                    if (gameClient && gameClient.mouseManager) {
                        gameClient.mouseManager.removeInteractionPoint(id);
                    }
                };
                
                // Helper para obter posi√ß√£o do mouse facilmente
                window.getMousePos = () => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.currentMousePos;
                    }
                    return { x: -1, y: -1 };
                };
                
                // Inicializar m√∫sica de fundo da √°rea inicial
                setTimeout(() => {
                    if (gameClient.areaManager) {
                        gameClient.areaManager.initializeAreaAudio();
                    }
                }, 500); // Pequeno delay para garantir que tudo esteja carregado
                
                
                // Canvas tem tamanho fixo - n√£o precisa de redimensionamento
                // window.addEventListener('resize', () => { ... }); // Removido
                
                // Iniciar game loop
                startGameLoop();
                
                console.log('üéÆ Blog interativo inicializado com sucesso!');
                
                // ===== CONEX√ÉO AUTOM√ÅTICA AO SERVIDOR =====
                console.log('üîó Iniciando conex√£o autom√°tica...');
                showConnectionStatus('üîÑ Conectando ao servidor...', true);
                
                try {
                    await gameClient.connect('Player');
                    console.log('‚úÖ Conectado automaticamente ao servidor multiplayer!');
                    showConnectionStatus('‚úÖ Conectado!', false);
                } catch (error) {
                    console.log('‚ö†Ô∏è Falha na conex√£o autom√°tica, continuando em modo singleplayer:', error.message);
                    showConnectionStatus('‚ö†Ô∏è Modo offline', false);
                    // N√£o √© um erro cr√≠tico - o jogo continua funcionando offline
                }
                
        // Configurar canvas com tamanho fixo
        function setupFixedCanvas() {
            const canvas = document.getElementById('gameCanvas');
            
            // Configurar dimens√µes do canvas sempre fixas (800x600)
            const FIXED_WIDTH = 800;
            const FIXED_HEIGHT = 600;
            
            // Verificar se √© dispositivo pequeno/m√≥vel (para joystick e c√¢mera)
            const isSmallScreen = window.innerWidth <= 800 || window.innerHeight <= 600;
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Definir dimens√µes fixas do canvas
            canvas.width = FIXED_WIDTH;
            canvas.height = FIXED_HEIGHT;
            
            // Controlar visibilidade inicial do joystick virtual
            const virtualJoystick = document.getElementById('virtualJoystick');
            if (virtualJoystick) {
                if (isSmallScreen || isMobile) {
                    virtualJoystick.style.display = 'block';
                } else {
                    virtualJoystick.style.display = 'none';
                }
            }
            
            console.log(`Canvas configurado com tamanho fixo: ${canvas.width}x${canvas.height}`);
            console.log(`Dispositivo m√≥vel/pequeno: ${isSmallScreen || isMobile} (c√¢mera e joystick ativos)`);
            
            // Salvar dimens√µes como constantes globais para f√°cil acesso
            window.GAME_WIDTH = FIXED_WIDTH;
            window.GAME_HEIGHT = FIXED_HEIGHT;
            
            // Fun√ß√£o para controlar joystick dinamicamente (canvas mant√©m tamanho fixo)
            function updateJoystickVisibility() {
                // Evitar execu√ß√£o excessiva
                if (updateJoystickVisibility.isExecuting) return;
                updateJoystickVisibility.isExecuting = true;
                
                const isSmallScreen = window.innerWidth <= 800 || window.innerHeight <= 600;
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const shouldShowJoystick = isSmallScreen || isMobile;
                
                // Controlar visibilidade do joystick virtual
                const virtualJoystick = document.getElementById('virtualJoystick');
                if (virtualJoystick) {
                    if (shouldShowJoystick) {
                        virtualJoystick.style.display = 'block';
                    } else {
                        virtualJoystick.style.display = 'none';
                    }
                }
                
                // Atualizar sistema de c√¢mera se existe
                if (window.gameClient && window.gameClient.camera) {
                    window.gameClient.camera.enabled = window.gameClient.shouldEnableCamera();
                }
                
                // Liberar flag ap√≥s timeout
                setTimeout(() => {
                    updateJoystickVisibility.isExecuting = false;
                }, 100);
            }
            
            // Listener para controlar joystick em mudan√ßas de orienta√ß√£o/tamanho
            window.addEventListener('resize', updateJoystickVisibility);
            window.addEventListener('orientationchange', () => {
                setTimeout(updateJoystickVisibility, 100); // Delay para orienta√ß√£o estabilizar
            });
        }
                
        } catch (error) {
            console.error('‚ùå Erro ao inicializar:', error);
        }
    }
        
    // ===== FUN√á√ïES DE UTILITY =====
    
    // Mostrar status de conex√£o
    function showConnectionStatus(message, show = true) {
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.style.display = show ? 'block' : 'none';
            
            // Auto-hide depois de 5 segundos se n√£o for um status de loading
            if (show && !message.includes('üîÑ')) {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 5000);
            }
        }
    }
    
    // Atualizar status de retry
    function updateRetryStatus(attempt, maxAttempts, url, delay = 0) {
        const isRender = url.includes('render.com');
        const serverType = isRender ? 'Render' : 'servidor';
        
        if (delay > 0) {
            showConnectionStatus(`‚è≥ Aguardando ${Math.round(delay/1000)}s para retry ${attempt}/${maxAttempts} (${serverType})`, true);
        } else {
            showConnectionStatus(`üîÑ Tentativa ${attempt}/${maxAttempts} - ${serverType}${isRender ? ' (pode estar em sleep)' : ''}`, true);
        }
    }

    // Game loop
        let lastTime = 0;
        function startGameLoop() {
            function gameLoop(currentTime) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                if (gameClient) {
                    gameClient.update(deltaTime);
                    gameClient.render();
                }

                requestAnimationFrame(gameLoop);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Fun√ß√£o para obter coordenadas do mouse em rela√ß√£o a uma div/element
        function getMousePosition(event, element) {
            const rect = element.getBoundingClientRect();
            const scaleX = element.width / rect.width;   // Escala X do canvas
            const scaleY = element.height / rect.height; // Escala Y do canvas
            
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY,
                // Coordenadas brutas (sem escala) caso precise
                rawX: event.clientX - rect.left,
                rawY: event.clientY - rect.top,
                // Informa√ß√µes da div
                elementRect: rect
            };
        }

        // Sistema de pontos de intera√ß√£o via mouse
        class MouseInteractionManager {
            constructor(gameClient) {
                this.gameClient = gameClient;
                this.canvas = gameClient.canvas;
                this.interactionPoints = [];
                this.isMouseDown = false;
                this.currentMousePos = { x: 0, y: 0 };
                
                this.setupMouseEvents();
                console.log('üñ±Ô∏è MouseInteractionManager inicializado');
            }

            setupMouseEvents() {
                // Rastrear movimento do mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    this.currentMousePos = getMousePosition(e, this.canvas);
                    this.checkInteractions();
                });

                // Clique do mouse
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    const mousePos = getMousePosition(e, this.canvas);
                    this.handleClick(mousePos);
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    this.isMouseDown = false;
                });

                // Deixar √°rea do canvas
                this.canvas.addEventListener('mouseleave', (e) => {
                    this.currentMousePos = { x: -1, y: -1 };
                });
            }

            // Adicionar ponto de intera√ß√£o
            addInteractionPoint(x, y, width, height, action, id = null, requiredArea = null) {
                const point = {
                    id: id || `point_${this.interactionPoints.length}`,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    action: action,
                    isHovered: false,
                    cooldown: 0,
                    requiredArea: requiredArea, // Nova propriedade para especificar √°rea necess√°ria
                    playerInside: false,
                    audioPlayed: false,
                    checkCounter: 0
                };
                
                this.interactionPoints.push(point);
                console.log(`üéØ Ponto de intera√ß√£o adicionado: ${point.id} em (${x}, ${y})${requiredArea ? ` [√Årea: ${requiredArea}]` : ''}`);
                return point;
            }

            // Remover ponto de intera√ß√£o
            removeInteractionPoint(id) {
                this.interactionPoints = this.interactionPoints.filter(point => point.id !== id);
                console.log(`üóëÔ∏è Ponto de intera√ß√£o removido: ${id}`);
            }

            // Verificar se ponto est√° dentro da √°rea
            isPointInside(mousePos, area) {
                return mousePos.x >= area.x && 
                       mousePos.x <= area.x + area.width &&
                       mousePos.y >= area.y && 
                       mousePos.y <= area.y + area.height;
            }

            // Verificar colis√£o entre ret√¢ngulos (player vs √°rea de intera√ß√£o)
            isPlayerColliding(player, area) {
                // Obter dimens√µes reais do player baseado na anima√ß√£o atual
                let playerWidth = player.width || 32;  // valor padr√£o se n√£o definido
                let playerHeight = player.height || 32; // valor padr√£o se n√£o definido
                
                // Tentar obter dimens√µes do sprite atual se dispon√≠vel
                if (player.currentSprite && player.currentSprite.width && player.currentSprite.height) {
                    playerWidth = player.currentSprite.width;
                    playerHeight = player.currentSprite.height;
                } else if (player.spriteManager && player.spriteManager.currentSprite) {
                    // Verificar se h√° informa√ß√µes no sprite manager
                    const currentSprite = player.spriteManager.currentSprite;
                    if (currentSprite.width && currentSprite.height) {
                        playerWidth = currentSprite.width;
                        playerHeight = currentSprite.height;
                    }
                }
                
                // Log das dimens√µes para debug
                if (playerWidth !== 32 || playerHeight !== 32) {
                    console.log(`üéÆ Usando dimens√µes do sprite: ${playerWidth}x${playerHeight}`);
                }
                
                // Detec√ß√£o de colis√£o AABB (Axis-Aligned Bounding Box)
                return player.x < area.x + area.width &&
                       player.x + playerWidth > area.x &&
                       player.y < area.y + area.height &&
                       player.y + playerHeight > area.y;
            }

            // Eventos de hover
            onPointEnter(point) {
                this.canvas.style.cursor = 'pointer';
                console.log(`üéØ Mouse entrou na √°rea: ${point.id}`);
            }

            onPointLeave(point) {
                this.canvas.style.cursor = 'default';
                console.log(`üéØ Mouse saiu da √°rea: ${point.id}`);
            }

            // Manipular clique
            handleClick(mousePos) {
                this.interactionPoints.forEach(point => {
                    if (this.isPointInside(mousePos, point) && point.cooldown === 0) {
                        console.log(`üñ±Ô∏è Clique em: ${point.id} na posi√ß√£o (${mousePos.x.toFixed(1)}, ${mousePos.y.toFixed(1)})`);
                        
                        // Executar a√ß√£o
                        if (typeof point.action === 'function') {
                            point.action(mousePos, point);
                        }
                        
                        // Cooldown para evitar spam
                        point.cooldown = 30; // ~0.5 segundos
                    }
                });
            }

            // Renderizar √°reas de debug
            renderDebugAreas(ctx) {
                if (!this.gameClient.debug.enabled) return;

                ctx.save();
                
                // Obter √°rea atual
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                this.interactionPoints.forEach(point => {
                    // S√≥ renderizar area_up_interaction quando estiver na √°rea 'up'
                    if (point.id === 'area_up_interaction' && currentArea !== 'up') {
                        return; // Pula a renderiza√ß√£o desta intera√ß√£o
                    }
                    
                    // √Årea de intera√ß√£o
                    ctx.strokeStyle = point.isHovered ? '#00FF00' : '#FF6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(point.x, point.y, point.width, point.height);
                    
                    // Label
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.fillText(point.id, point.x, point.y - 5);
                    
                    // Highlight se estiver hovering
                    if (point.isHovered) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                        ctx.fillRect(point.x, point.y, point.width, point.height);
                    }
                });

                // Mostrar posi√ß√£o atual do mouse
                if (this.currentMousePos.x >= 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(this.currentMousePos.x, this.currentMousePos.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Coordenadas
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '10px Arial';
                    ctx.fillText(`(${this.currentMousePos.x.toFixed(0)}, ${this.currentMousePos.y.toFixed(0)})`, 
                                this.currentMousePos.x + 5, this.currentMousePos.y - 5);
                }
                
                ctx.restore();
            }

            // Atualizar visibilidade das intera√ß√µes baseada na √°rea atual
            updateInteractionsForArea(currentArea) {
                this.interactionPoints.forEach(point => {
                    // Intera√ß√£o area_up_interaction s√≥ funciona na √°rea "up"
                    if (point.id === 'area_up_interaction') {
                        point.visible = (currentArea === 'up');
                        if (!point.visible) {
                            point.isHovered = false; // Reset hover se n√£o estiver vis√≠vel
                        }
                    }
                });
            }

            // Verificar intera√ß√µes - otimizado por √°rea
            checkInteractions() {
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                // Cache do player para evitar m√∫ltiplas buscas (s√≥ se necess√°rio)
                let playerCached = false;
                
                this.interactionPoints.forEach(point => {
                    // OTIMIZA√á√ÉO PRINCIPAL: S√≥ processar intera√ß√µes da √°rea atual
                    if (point.requiredArea && point.requiredArea !== currentArea) {
                        // Reset estado se n√£o estiver na √°rea correta
                        if (point.isHovered) point.isHovered = false;
                        if (point.playerInside) {
                            point.playerInside = false;
                            point.audioPlayed = false; // Reset √°udio ao sair da √°rea
                        }
                        return; // Skip processamento - ECONOMIA MASSIVA DE CPU
                    }

                    // Verifica√ß√£o de cooldown
                    if (point.cooldown > 0) {
                        point.cooldown--;
                    }

                    // Verifica√ß√£o de mouse (sempre ativa)
                    const wasHovered = point.isHovered;
                    point.isHovered = this.isPointInside(this.currentMousePos, point);

                    // Eventos de mouse
                    if (point.isHovered && !wasHovered) {
                        this.onPointEnter(point);
                    }
                    
                    if (!point.isHovered && wasHovered) {
                        this.onPointLeave(point);
                    }

                    // Verifica√ß√£o de personagem (s√≥ para intera√ß√µes espec√≠ficas e na √°rea correta)
                    if (point.id === 'area_up_interaction' && currentArea === 'up') {
                        // Cache player apenas quando necess√°rio
                        if (!playerCached) {
                            if (!this.cachedPlayer || this.playerCacheTime < Date.now() - 100) {
                                this.cachedPlayer = this.findPlayer();
                                this.playerCacheTime = Date.now();
                            }
                            playerCached = true;
                        }
                        
                        if (this.cachedPlayer) {
                            this.checkPlayerInInteractionAreaOptimized(point);
                        }
                    }
                });
            }

            // Buscar player com fallbacks
            findPlayer() {
                let player = this.gameClient.player;
                
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                return player;
            }

            // Vers√£o otimizada da verifica√ß√£o do personagem
            checkPlayerInInteractionAreaOptimized(point) {
                const player = this.cachedPlayer;
                if (!player) return;

                // Throttling: s√≥ verificar a cada 5 frames (~83ms a 60fps)
                point.checkCounter = (point.checkCounter || 0) + 1;
                if (point.checkCounter % 5 !== 0) return;

                const wasPlayerInside = point.playerInside || false;
                // NOVA: Usar detec√ß√£o de colis√£o entre ret√¢ngulos ao inv√©s de apenas um ponto
                const isPlayerInside = this.isPlayerColliding(player, point);

                // Personagem entrou na √°rea de intera√ß√£o
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o √°udio j√° foi tocado nesta sess√£o na √°rea
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`üö™ Personagem colidiu com √°rea de teleporte! Player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)}) Dimens√µes: ${player.width || 32}x${player.height || 32}`);
                        
                        // FREEZE o player imediatamente para anima√ß√£o de teleporte
                        if (player.freeze) {
                            player.freeze();
                        }
                        
                        // Reproduzir √°udio de teleporte
                        this.playAudioImmediate('songs/tp_song.mp3');
                        
                        // Redirecionar ap√≥s o √°udio terminar (3.89s + margem = 4s)
                        setTimeout(() => {
                            console.log('üó°Ô∏è Portal Ativado! Redirecionando para o blog...');
                            window.location.href = 'pages/blog.html';
                        }, 4000); // 4 segundos para garantir que o √°udio termine
                    } else {
                        console.log('üîá √Åudio j√° foi tocado nesta entrada na √°rea');
                    }
                }
                
                // Personagem saiu da √°rea de intera√ß√£o
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do √°udio ao sair
                    
                    // Descongelar o player se ele saiu da √°rea
                    if (player.unfreeze) {
                        player.unfreeze();
                    }
                    
                    console.log('üö∂ Personagem saiu da √°rea de teleporte - √°udio resetado e player desfrozen');
                }
            }

            // Reproduzir √°udio de forma mais eficiente
            playAudioImmediate(audioPath) {
                try {
                    console.log(`üéµ Tentando reproduzir √°udio: ${audioPath}`);
                    if (window.audioManager) {
                        // Tentar m√∫ltiplos m√©todos de reprodu√ß√£o para garantir que funcione
                        audioManager.playAudioFast(audioPath);
                        
                        // Fallback: tentar m√©todo padr√£o tamb√©m
                        setTimeout(() => {
                            audioManager.playAudio(audioPath);
                        }, 100);
                        
                        console.log('üéµ Comando de reprodu√ß√£o enviado');
                        
                        // Nota: Redirecionamento agora √© controlado pela intera√ß√£o espec√≠fica
                        // para permitir timing preciso com o freeze do player
                        
                    } else {
                        console.error('‚ùå AudioManager n√£o dispon√≠vel');
                    }
                } catch (error) {
                    console.error('‚ùå Erro ao reproduzir √°udio:', error);
                }
            }

            // Verificar se o personagem est√° dentro da √°rea de intera√ß√£o (m√©todo antigo - mantido para compatibilidade)
            checkPlayerInInteractionArea(point) {
                // Tentar m√∫ltiplas formas de acessar o player
                let player = this.gameClient.player;
                
                // Se n√£o encontrar, tentar pelo gameCore
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                // Se ainda n√£o encontrar, tentar pelo frameBasedGame
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                if (!player) {
                    console.log('üö´ Player n√£o encontrado - verificando √°rea s√≥ com mouse');
                    return;
                }

                const wasPlayerInside = point.playerInside || false;
                // NOVA: Usar detec√ß√£o de colis√£o entre ret√¢ngulos ao inv√©s de apenas um ponto
                const isPlayerInside = this.isPlayerColliding(player, point);

                // Personagem entrou na √°rea de intera√ß√£o
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o √°udio j√° foi tocado nesta sess√£o na √°rea
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`üö™ Personagem colidiu com √°rea de teleporte! Player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)}) Dimens√µes: ${player.width || 32}x${player.height || 32}`);
                        
                        // Reproduzir √°udio e redirecionar
                        if (window.audioManager) {
                            audioManager.playAudio('songs/tp_song.mp3');
                        }
                        
                        console.log('üéµ Portal ativado! Redirecionando para o blog...');
                        
                        // Redirecionar ap√≥s delay para ouvir o √°udio
                        setTimeout(() => {
                            window.location.href = 'pages/blog.html';
                        }, 800); // 800ms delay para ouvir o som completo
                    } else {
                        console.log('üîá √Åudio j√° foi tocado nesta entrada na √°rea');
                    }
                }
                
                // Personagem saiu da √°rea de intera√ß√£o
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do √°udio ao sair
                    console.log('üö∂ Personagem saiu da √°rea de teleporte - √°udio resetado');
                }
            }
        }

        // Teclas especiais
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                // Toggle debug de colis√µes
                if (window.gameCore) {
                    gameCore.collisionManager.debugMode = !gameCore.collisionManager.debugMode;
                    console.log('üêõ Debug de colis√µes:', gameCore.collisionManager.debugMode);
                }
            }
            
            if (e.key === 'F2') {
                // Toggle debug de intera√ß√µes
                if (window.gameCore) {
                    gameCore.interactionManager.debugMode = !gameCore.interactionManager.debugMode;
                    console.log('üêõ Debug de intera√ß√µes:', gameCore.interactionManager.debugMode);
                }
            }
            
            if (e.key === 'F3') {
                // Reset posi√ß√£o do player
                if (gameClient && gameClient.player) {
                    gameClient.player.x = 400;
                    gameClient.player.y = 300;
                    console.log('üîÑ Posi√ß√£o resetada');
                }
            }
            
            if (e.key === 'F4') {
                // Reconectar ao servidor
                if (gameClient) {
                    console.log('üîÑ Tentando reconectar...');
                    if (gameClient.gameState.isConnected) {
                        gameClient.disconnect();
                        setTimeout(() => {
                            gameClient.connect('Player').catch(err => {
                                console.log('‚ùå Falha na reconex√£o:', err.message);
                            });
                        }, 1000);
                    } else {
                        gameClient.connect('Player').catch(err => {
                            console.log('‚ùå Falha na conex√£o:', err.message);
                        });
                    }
                }
            }
        });

        // Bot√£o de teste de conex√£o
        document.addEventListener('DOMContentLoaded', () => {
            const testButton = document.getElementById('testConnection');
            if (testButton) {
                testButton.addEventListener('click', async () => {
                    console.log('üß™ Iniciando teste de conex√£o...');
                    testButton.textContent = 'üîÑ Testando...';
                    testButton.disabled = true;
                    
                    try {
                        const networkManager = new NetworkManager();
                        await networkManager.connect({
                            name: 'TestPlayer',
                            color: '#00FF00'
                        });
                        
                        console.log('‚úÖ Teste de conex√£o bem-sucedido!');
                        testButton.textContent = '‚úÖ Conectado!';
                        testButton.style.background = '#4CAF50';
                        
                        // Desconectar ap√≥s teste
                        setTimeout(() => {
                            networkManager.disconnect();
                            testButton.textContent = 'üîó Testar Conex√£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                        
                    } catch (error) {
                        console.error('‚ùå Teste de conex√£o falhou:', error);
                        testButton.textContent = '‚ùå Falhou';
                        testButton.style.background = '#f44336';
                        
                        setTimeout(() => {
                            testButton.textContent = 'üîó Testar Conex√£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                    }
                });
            }
        });

        // Inicializar quando a p√°gina carregar
        window.addEventListener('load', () => {
            initGame();
        });
    </script>

</body>
</html>