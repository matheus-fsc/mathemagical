<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: ws: wss: https: 'unsafe-inline'; connect-src 'self' ws: wss: https: data: blob:;">
    <title>üó°Ô∏è Link's Adventure Blog | A Legendary Journey</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="favicon.ico">
    <!-- CSS Styles -->
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/layout.css">
    <link rel="stylesheet" href="styles/game.css">
    <link rel="stylesheet" href="styles/buttons.css">
    <link rel="stylesheet" href="styles/panels.css">
    <link rel="stylesheet" href="styles/effects.css">
</head>
<body>
    <!-- Main Container -->
    <div class="main-container">
        
        <!-- Header Vintage -->
        <header class="vintage-header">
            <h1 class="title">üó°Ô∏è LINK'S ADVENTURE BLOG</h1>
            <p class="subtitle">~ A Legendary Journey Through Hyrule & Code ~</p>
        </header>

        <!-- Game Section -->
        <section class="game-section">
            <div class="game-container">
                <canvas id="gameCanvas"></canvas>
                <div class="game-status" id="gameStatus">
                    üü° Modo Aventura Ativo
                </div>
                <div class="connection-status" id="connectionStatus" style="font-size: 12px; color: #666; margin-top: 5px; display: none;">
                    üîÑ Conectando...
                </div>
            </div>
        </section>

        <!-- Navigation Section -->
        <section class="navigation-section">
            <nav class="interactive-buttons">
                <a href="#blog" class="zelda-button" data-target="blog" data-hitbox-x="0.15" data-hitbox-y="0.2">
                    <span class="button-icon">üìù</span>
                    <span class="button-title">Blog Adventures</span>
                    <span class="button-desc">Jornadas e descobertas</span>
                </a>
                
                <a href="#projects" class="zelda-button" data-target="projects" data-hitbox-x="0.5" data-hitbox-y="0.2">
                    <span class="button-icon">üõ†Ô∏è</span>
                    <span class="button-title">Code Dungeons</span>
                    <span class="button-desc">Projetos e experimentos</span>
                </a>
                
                <a href="#gallery" class="zelda-button" data-target="gallery" data-hitbox-x="0.85" data-hitbox-y="0.2">
                    <span class="button-icon">üñºÔ∏è</span>
                    <span class="button-title">Treasure Gallery</span>
                    <span class="button-desc">Arte e capturas</span>
                </a>
                
                <a href="#about" class="zelda-button" data-target="about" data-hitbox-x="0.15" data-hitbox-y="0.6">
                    <span class="button-icon">üë§</span>
                    <span class="button-title">Hero's Profile</span>
                    <span class="button-desc">Sobre o aventureiro</span>
                </a>
                
                <a href="#links" class="zelda-button" data-target="links" data-hitbox-x="0.5" data-hitbox-y="0.6">
                    <span class="button-icon">üîó</span>
                    <span class="button-title">Sacred Links</span>
                    <span class="button-desc">Conex√µes importantes</span>
                </a>
                
                <a href="#contact" class="zelda-button" data-target="contact" data-hitbox-x="0.85" data-hitbox-y="0.6">
                    <span class="button-icon">üì¨</span>
                    <span class="button-title">Send a Message</span>
                    <span class="button-desc">Fale com o her√≥i</span>
                </a>
            </nav>
        </section>

        <!-- Info Section -->
        <section class="info-section">
            <div class="info-panel">
                <h3>üéÆ Como Navegar na Aventura</h3>
                <p>
                    Bem-vindo ao meu cantinho digital inspirado em Zelda! Use o Link para explorar e interagir com os elementos da p√°gina. 
                    Move-se pelo mundo e ataque os bot√µes dourados para navegar pelas diferentes se√ß√µes do blog.
                </p>
        
        <div class="controls-info">
            <div class="control-item">
                <span class="control-key">WASD / Setas:</span> Mover o Link
            </div>
            <div class="control-item">
                    <div class="controls-info">
                    <div class="control-item">
                        <span class="control-key">WASD / Setas:</span> Mover Link
                    </div>
                    <div class="control-item">
                        <span class="control-key">X / Z / Enter:</span> Atacar bot√µes
                    </div>
                    <div class="control-item">
                        <span class="control-key">F1:</span> Mostrar/ocultar debug
                    </div>
                    <div class="control-item">
                        <span class="control-key">F2:</span> Reset posi√ß√£o
                    </div>
                    <div class="control-item">
                        <span class="control-key">F4:</span> Reconectar servidor
                    </div>
                    <div class="control-item">
                        <button id="testConnection" class="control-key" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; cursor: pointer;">üîó Testar Conex√£o</button>
                    </div>
                </div>
            </div>

            <div class="info-panel">
                <h3>üåü Sobre Este Blog</h3>
                <p>
                    Este √© meu espa√ßo pessoal onde compartilho aventuras em programa√ß√£o, projetos criativos e reflex√µes sobre tecnologia. 
                    Inspirado na nostalgia dos primeiros sites da internet e na magia atemporal de The Legend of Zelda.
                </p>
                <p>
                    Cada se√ß√£o √© uma dungeon diferente com seus pr√≥prios tesouros e segredos. Explore √† vontade e descubra o que cada 
                    √°rea tem para oferecer! Os bot√µes dourados s√£o pontos de intera√ß√£o - aproxime-se e ataque para ativ√°-los.
                </p>
            </div>
        </section>

        <!-- Footer -->
        <footer class="vintage-footer">
            <p>‚öîÔ∏è Link's Adventure Blog - Crafted with ‚ù§Ô∏è and nostalgia ‚öîÔ∏è</p>
            <div class="visitor-counter">
                Visitors: 001337
            </div>
            <p style="font-size: 0.8rem; margin-top: 10px; color: #888;">
                "It's dangerous to go alone! Take this website." - Old Man, 2025
            </p>
        </footer>
        
    </div> <!-- End main-container -->

  <!-- Game Scripts -->
<script src="socket.io.min.js?v=1.0.0"></script>
<script>
  // Debug: Verificar se Socket.io foi carregado
  console.log('üîç Socket.io dispon√≠vel:', typeof io !== 'undefined' ? '‚úÖ SIM' : '‚ùå N√ÉO');
  if (typeof io !== 'undefined') {
    console.log('üì¶ Socket.io version:', io.version || 'unknown');
  }
</script>
<script src="config/serverConfig.js"></script>
<script src="legacy/areaManager.js"></script>
<script src="input/inputManager.js"></script>
<script src="sprites/frameBasedSpriteManager.js"></script>
<script src="legacy/frameBasedPlayer.js"></script>
<script src="network/mockServer.js"></script>
<script>
  // Debug: Verificar se MockServer foi carregado
  console.log('ü§ñ MockServer dispon√≠vel:', typeof MockServer !== 'undefined' ? '‚úÖ SIM' : '‚ùå N√ÉO');
</script>
<script src="network/networkManager.js"></script>
<script src="network/multiplayerManager.js"></script>

<!-- Component System -->
<script src="managers/AssetLoader.js"></script>
<script src="managers/SceneManager.js"></script>
<script src="managers/CollisionManager.js"></script>
<script src="managers/InteractionManager.js"></script>
<script src="components/GameCore.js"></script>

<script src="core/gameClient.js"></script>

    <script>
        // Inicializa√ß√£o do jogo
        let gameClient = null;

        // Inicializar jogo
        async function initGame() {
            try {
                // Configurar canvas responsivo
                setupResponsiveCanvas();
                
                gameClient = new GameClient();
                await gameClient.init('gameCanvas');
                
                // Sistema de √°udio otimizado para baixa lat√™ncia
                const audioManager = {
                    audioCache: new Map(),
                    preloadedAudios: new Set(),
                    currentBackgroundMusic: null,
                    backgroundMusicSrc: null,
                    isBackgroundPlaying: false,
                    
                    // Pr√©-carregar √°udios cr√≠ticos
                    preloadAudio(src) {
                        if (!this.audioCache.has(src)) {
                            const audio = new Audio(src);
                            audio.preload = 'auto';
                            audio.volume = 0.5;
                            
                            // Carregar imediatamente
                            audio.load();
                            
                            this.audioCache.set(src, audio);
                            
                            audio.addEventListener('canplaythrough', () => {
                                this.preloadedAudios.add(src);
                                console.log('üéµ √Åudio pr√©-carregado:', src);
                            }, { once: true });
                        }
                        return this.audioCache.get(src);
                    },
                    
                    loadAudio(src) {
                        if (!this.audioCache.has(src)) {
                            return this.preloadAudio(src);
                        }
                        return this.audioCache.get(src);
                    },

                    // Iniciar m√∫sica de fundo cont√≠nua
                    startBackgroundMusic(src = 'songs/backgroundsond.mp3', volume = 0.3) {
                        try {
                            // Se j√° est√° tocando a mesma m√∫sica, n√£o reiniciar
                            if (this.backgroundMusicSrc === src && this.isBackgroundPlaying) {
                                console.log('üéµ M√∫sica de fundo j√° est√° tocando:', src);
                                return;
                            }

                            // Parar m√∫sica anterior se existir
                            this.stopBackgroundMusic();

                            const audio = this.loadAudio(src);
                            audio.loop = true;
                            audio.volume = volume;
                            
                            const playPromise = audio.play();
                            if (playPromise !== undefined) {
                                playPromise
                                    .then(() => {
                                        this.currentBackgroundMusic = audio;
                                        this.backgroundMusicSrc = src;
                                        this.isBackgroundPlaying = true;
                                        console.log('üéµ M√∫sica de fundo iniciada:', src);
                                    })
                                    .catch(error => {
                                        console.warn('‚ö†Ô∏è Autoplay de m√∫sica de fundo bloqueado:', error);
                                    });
                            }
                        } catch (error) {
                            console.error('‚ùå Erro ao iniciar m√∫sica de fundo:', error);
                        }
                    },

                    // Parar m√∫sica de fundo
                    stopBackgroundMusic() {
                        if (this.currentBackgroundMusic) {
                            this.currentBackgroundMusic.pause();
                            this.currentBackgroundMusic.currentTime = 0;
                            this.currentBackgroundMusic = null;
                            this.backgroundMusicSrc = null;
                            this.isBackgroundPlaying = false;
                            console.log('üîá M√∫sica de fundo parada');
                        }
                    },

                    // Pausar m√∫sica de fundo temporariamente
                    pauseBackgroundMusic() {
                        if (this.currentBackgroundMusic && this.isBackgroundPlaying) {
                            this.currentBackgroundMusic.pause();
                            this.isBackgroundPlaying = false;
                            console.log('‚è∏Ô∏è M√∫sica de fundo pausada');
                        }
                    },

                    // Retomar m√∫sica de fundo
                    resumeBackgroundMusic() {
                        if (this.currentBackgroundMusic && !this.isBackgroundPlaying) {
                            const playPromise = this.currentBackgroundMusic.play();
                            if (playPromise !== undefined) {
                                playPromise
                                    .then(() => {
                                        this.isBackgroundPlaying = true;
                                        console.log('‚ñ∂Ô∏è M√∫sica de fundo retomada');
                                    })
                                    .catch(error => {
                                        console.warn('‚ö†Ô∏è Erro ao retomar m√∫sica de fundo:', error);
                                    });
                            }
                        }
                    },
                    
                    // M√©todo otimizado para reprodu√ß√£o instant√¢nea (efeitos sonoros)
                    playAudioFast(src = 'songs/tp_song.mp3') {
                        try {
                            const audio = this.loadAudio(src);
                            
                            // Se j√° est√° carregado, reproduzir imediatamente
                            if (this.preloadedAudios.has(src)) {
                                audio.currentTime = 0;
                                audio.play().catch(e => console.warn('üîá Autoplay bloqueado:', e));
                                console.log('üéµ √Åudio reproduzido instantaneamente:', src);
                            } else {
                                // Se n√£o carregou ainda, tentar mesmo assim
                                console.log('‚è≥ Tentando reproduzir √°udio ainda carregando:', src);
                                audio.play().catch(e => console.warn('üîá √Åudio n√£o pronto:', e));
                            }
                        } catch (error) {
                            console.error('‚ùå Erro ao reproduzir √°udio:', error);
                        }
                    },
                    
                    // M√©todo original (mantido para compatibilidade)
                    playAudio(src = 'songs/tp_song.mp3') {
                        try {
                            const audio = this.loadAudio(src);
                            audio.currentTime = 0; // Restart from beginning
                            const playPromise = audio.play();
                            
                            if (playPromise !== undefined) {
                                playPromise
                                    .then(() => {
                                        console.log('üéµ √Åudio reproduzido com sucesso:', src);
                                    })
                                    .catch(error => {
                                        console.warn('‚ö†Ô∏è Autoplay bloqueado, necess√°ria intera√ß√£o do usu√°rio:', error);
                                    });
                            }
                        } catch (error) {
                            console.error('‚ùå Erro ao reproduzir √°udio:', error);
                        }
                    },
                    
                    stopAudio() {
                        this.audioCache.forEach(audio => {
                            audio.pause();
                            audio.currentTime = 0;
                        });
                    },
                    
                    // Pr√©-carregar √°udios importantes
                    preloadCriticalAudios() {
                        const criticalAudios = [
                            'songs/tp_song.mp3',
                            'songs/backgroundsond.mp3'
                            // Adicionar outros √°udios cr√≠ticos aqui
                        ];
                        
                        criticalAudios.forEach(src => {
                            this.preloadAudio(src);
                        });
                        
                        console.log('üéµ Iniciando pr√©-carregamento de √°udios cr√≠ticos...');
                    }
                };
                
                // Tornar o audioManager global
                window.audioManager = audioManager;
                
                // Pr√©-carregar √°udios cr√≠ticos imediatamente
                audioManager.preloadCriticalAudios();
                
                // Inicializar sistema de componentes
                window.gameCore = new GameCore();
                await gameCore.init('gameCanvas');
                
                // Integrar com o sistema legado
                gameCore.integrateWithLegacySystem(gameClient);
                
                // Inicializar sistema de intera√ß√£o com mouse
                gameClient.mouseManager = new MouseInteractionManager(gameClient);
                
                // Ponto de intera√ß√£o na √°rea "up" - centralizado na tela
                const canvas = document.getElementById('gameCanvas');
                const interactionWidth = 76.9;  // mant√©m o mesmo tamanho
                const interactionHeight = 50.5; // mant√©m o mesmo tamanho
                const interactionX = (canvas.width / 2) - (interactionWidth / 2);   // centralizado horizontalmente
                const interactionY = (canvas.height / 2) - (interactionHeight / 2); // centralizado verticalmente
                
                gameClient.mouseManager.addInteractionPoint(
                    interactionX,        // x
                    interactionY,        // y
                    interactionWidth,    // width
                    interactionHeight,   // height
                    (mousePos, point) => {
                        // S√≥ funciona na √°rea "up" (redundante, mas mantido para seguran√ßa)
                        if (gameClient.areaManager && gameClient.areaManager.getCurrentArea() === 'up') {
                            // Reproduzir √°udio de teleporte
                            if (window.audioManager) {
                                audioManager.playAudio('songs/tp_song.mp3');
                            }
                            alert(`üó°Ô∏è Portal Ativado! üéµ\nCoordenadas: (${mousePos.x.toFixed(1)}, ${mousePos.y.toFixed(1)})\n√Åudio: tp_song.mp3`);
                        } else {
                            console.log('üö´ Esta intera√ß√£o s√≥ funciona na √°rea UP');
                        }
                    },
                    'area_up_interaction',
                    'up' // NOVA: Especifica que esta intera√ß√£o s√≥ funciona na √°rea "up"
                );
                
                // Fun√ß√£o helper para facilitar cria√ß√£o de pontos de intera√ß√£o
                window.addInteractionPoint = (x, y, width, height, action, id, requiredArea = null) => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.addInteractionPoint(x, y, width, height, action, id, requiredArea);
                    }
                };
                
                window.removeInteractionPoint = (id) => {
                    if (gameClient && gameClient.mouseManager) {
                        gameClient.mouseManager.removeInteractionPoint(id);
                    }
                };
                
                // Helper para obter posi√ß√£o do mouse facilmente
                window.getMousePos = () => {
                    if (gameClient && gameClient.mouseManager) {
                        return gameClient.mouseManager.currentMousePos;
                    }
                    return { x: -1, y: -1 };
                };
                
                // Inicializar m√∫sica de fundo da √°rea inicial
                setTimeout(() => {
                    if (gameClient.areaManager) {
                        gameClient.areaManager.initializeAreaAudio();
                    }
                }, 500); // Pequeno delay para garantir que tudo esteja carregado
                
                
                // Configurar redimensionamento
                window.addEventListener('resize', () => {
                    setupResponsiveCanvas();
                });
                
                // Iniciar game loop
                startGameLoop();
                
                // Atualizar status do jogo
                updateGameStatus();
                
                console.log('üéÆ Blog interativo inicializado com sucesso!');
                
                // ===== CONEX√ÉO AUTOM√ÅTICA AO SERVIDOR =====
                console.log('üîó Iniciando conex√£o autom√°tica...');
                showConnectionStatus('üîÑ Conectando ao servidor...', true);
                
                try {
                    await gameClient.connect('Player');
                    console.log('‚úÖ Conectado automaticamente ao servidor multiplayer!');
                    showConnectionStatus('‚úÖ Conectado!', false);
                } catch (error) {
                    console.log('‚ö†Ô∏è Falha na conex√£o autom√°tica, continuando em modo singleplayer:', error.message);
                    showConnectionStatus('‚ö†Ô∏è Modo offline', false);
                    // N√£o √© um erro cr√≠tico - o jogo continua funcionando offline
                }
                
        // Configurar canvas responsivo
        function setupResponsiveCanvas() {
            const canvas = document.getElementById('gameCanvas');
            const container = canvas.parentElement;
            
            // Obter dimens√µes do container
            const containerRect = container.getBoundingClientRect();
            
            // Usar dimens√µes mais flex√≠veis para melhor responsividade
            // Permitir que o canvas use o m√°ximo de espa√ßo dispon√≠vel
            let canvasWidth = Math.max(containerRect.width - 8, 400); // M√≠nimo 400px
            let canvasHeight = Math.max(containerRect.height - 8, 300); // M√≠nimo 300px
            
            // Aplicar uma propor√ß√£o m√°xima para telas muito largas
            const maxAspectRatio = 16/9; // M√°ximo ultra-wide
            const minAspectRatio = 4/3;  // M√≠nimo tradicional
            
            const currentRatio = canvasWidth / canvasHeight;
            
            if (currentRatio > maxAspectRatio) {
                // Muito largo - ajustar largura
                canvasWidth = canvasHeight * maxAspectRatio;
            } else if (currentRatio < minAspectRatio) {
                // Muito alto - ajustar altura
                canvasHeight = canvasWidth / minAspectRatio;
            }
            
            // Garantir que n√£o exceda container
            if (canvasWidth > containerRect.width - 8) {
                canvasWidth = containerRect.width - 8;
                canvasHeight = canvasWidth / (currentRatio > maxAspectRatio ? maxAspectRatio : currentRatio);
            }
            
            if (canvasHeight > containerRect.height - 8) {
                canvasHeight = containerRect.height - 8;
                canvasWidth = canvasHeight * (currentRatio < minAspectRatio ? minAspectRatio : currentRatio);
            }
            
            // Definir dimens√µes do canvas (valores inteiros para melhor renderiza√ß√£o)
            canvas.width = Math.floor(canvasWidth);
            canvas.height = Math.floor(canvasHeight);
            
            console.log(`Canvas redimensionado para: ${canvas.width}x${canvas.height} (ratio: ${(canvas.width/canvas.height).toFixed(2)})`);
        }
                
        } catch (error) {
            console.error('‚ùå Erro ao inicializar:', error);
        }
    }
        
    // ===== FUN√á√ïES DE UTILITY =====
    
    // Mostrar status de conex√£o
    function showConnectionStatus(message, show = true) {
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.style.display = show ? 'block' : 'none';
            
            // Auto-hide depois de 5 segundos se n√£o for um status de loading
            if (show && !message.includes('üîÑ')) {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 5000);
            }
        }
    }
    
    // Atualizar status de retry
    function updateRetryStatus(attempt, maxAttempts, url, delay = 0) {
        const isRender = url.includes('render.com');
        const serverType = isRender ? 'Render' : 'servidor';
        
        if (delay > 0) {
            showConnectionStatus(`‚è≥ Aguardando ${Math.round(delay/1000)}s para retry ${attempt}/${maxAttempts} (${serverType})`, true);
        } else {
            showConnectionStatus(`üîÑ Tentativa ${attempt}/${maxAttempts} - ${serverType}${isRender ? ' (pode estar em sleep)' : ''}`, true);
        }
    }

    // Game loop
        let lastTime = 0;
        function startGameLoop() {
            function gameLoop(currentTime) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                if (gameClient) {
                    gameClient.update(deltaTime);
                    gameClient.render();
                }

                requestAnimationFrame(gameLoop);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Atualizar status do jogo
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            
            setInterval(() => {
                if (gameClient) {
                    let status = 'üî¥ Parado';
                    
                    if (gameClient.gameState.isConnected) {
                        const playerCount = gameClient.gameState.players ? Object.keys(gameClient.gameState.players).length : 1;
                        status = `üü¢ Multiplayer (${playerCount} jogador${playerCount > 1 ? 'es' : ''})`;
                    } else if (gameClient.gameState.isGameRunning) {
                        status = 'üü° Modo Aventura Solo';
                    }
                    
                    statusElement.textContent = status;
                }
            }, 1000);
        }

        // Fun√ß√£o para obter coordenadas do mouse em rela√ß√£o a uma div/element
        function getMousePosition(event, element) {
            const rect = element.getBoundingClientRect();
            const scaleX = element.width / rect.width;   // Escala X do canvas
            const scaleY = element.height / rect.height; // Escala Y do canvas
            
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY,
                // Coordenadas brutas (sem escala) caso precise
                rawX: event.clientX - rect.left,
                rawY: event.clientY - rect.top,
                // Informa√ß√µes da div
                elementRect: rect
            };
        }

        // Sistema de pontos de intera√ß√£o via mouse
        class MouseInteractionManager {
            constructor(gameClient) {
                this.gameClient = gameClient;
                this.canvas = gameClient.canvas;
                this.interactionPoints = [];
                this.isMouseDown = false;
                this.currentMousePos = { x: 0, y: 0 };
                
                this.setupMouseEvents();
                console.log('üñ±Ô∏è MouseInteractionManager inicializado');
            }

            setupMouseEvents() {
                // Rastrear movimento do mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    this.currentMousePos = getMousePosition(e, this.canvas);
                    this.checkInteractions();
                });

                // Clique do mouse
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    const mousePos = getMousePosition(e, this.canvas);
                    this.handleClick(mousePos);
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    this.isMouseDown = false;
                });

                // Deixar √°rea do canvas
                this.canvas.addEventListener('mouseleave', (e) => {
                    this.currentMousePos = { x: -1, y: -1 };
                });
            }

            // Adicionar ponto de intera√ß√£o
            addInteractionPoint(x, y, width, height, action, id = null, requiredArea = null) {
                const point = {
                    id: id || `point_${this.interactionPoints.length}`,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    action: action,
                    isHovered: false,
                    cooldown: 0,
                    requiredArea: requiredArea, // Nova propriedade para especificar √°rea necess√°ria
                    playerInside: false,
                    audioPlayed: false,
                    checkCounter: 0
                };
                
                this.interactionPoints.push(point);
                console.log(`üéØ Ponto de intera√ß√£o adicionado: ${point.id} em (${x}, ${y})${requiredArea ? ` [√Årea: ${requiredArea}]` : ''}`);
                return point;
            }

            // Remover ponto de intera√ß√£o
            removeInteractionPoint(id) {
                this.interactionPoints = this.interactionPoints.filter(point => point.id !== id);
                console.log(`üóëÔ∏è Ponto de intera√ß√£o removido: ${id}`);
            }

            // Verificar se ponto est√° dentro da √°rea
            isPointInside(mousePos, area) {
                return mousePos.x >= area.x && 
                       mousePos.x <= area.x + area.width &&
                       mousePos.y >= area.y && 
                       mousePos.y <= area.y + area.height;
            }

            // Eventos de hover
            onPointEnter(point) {
                this.canvas.style.cursor = 'pointer';
                console.log(`üéØ Mouse entrou na √°rea: ${point.id}`);
            }

            onPointLeave(point) {
                this.canvas.style.cursor = 'default';
                console.log(`üéØ Mouse saiu da √°rea: ${point.id}`);
            }

            // Manipular clique
            handleClick(mousePos) {
                this.interactionPoints.forEach(point => {
                    if (this.isPointInside(mousePos, point) && point.cooldown === 0) {
                        console.log(`üñ±Ô∏è Clique em: ${point.id} na posi√ß√£o (${mousePos.x.toFixed(1)}, ${mousePos.y.toFixed(1)})`);
                        
                        // Executar a√ß√£o
                        if (typeof point.action === 'function') {
                            point.action(mousePos, point);
                        }
                        
                        // Cooldown para evitar spam
                        point.cooldown = 30; // ~0.5 segundos
                    }
                });
            }

            // Renderizar √°reas de debug
            renderDebugAreas(ctx) {
                if (!this.gameClient.debug.enabled) return;

                ctx.save();
                
                // Obter √°rea atual
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                this.interactionPoints.forEach(point => {
                    // S√≥ renderizar area_up_interaction quando estiver na √°rea 'up'
                    if (point.id === 'area_up_interaction' && currentArea !== 'up') {
                        return; // Pula a renderiza√ß√£o desta intera√ß√£o
                    }
                    
                    // √Årea de intera√ß√£o
                    ctx.strokeStyle = point.isHovered ? '#00FF00' : '#FF6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(point.x, point.y, point.width, point.height);
                    
                    // Label
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.fillText(point.id, point.x, point.y - 5);
                    
                    // Highlight se estiver hovering
                    if (point.isHovered) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                        ctx.fillRect(point.x, point.y, point.width, point.height);
                    }
                });

                // Mostrar posi√ß√£o atual do mouse
                if (this.currentMousePos.x >= 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(this.currentMousePos.x, this.currentMousePos.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Coordenadas
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '10px Arial';
                    ctx.fillText(`(${this.currentMousePos.x.toFixed(0)}, ${this.currentMousePos.y.toFixed(0)})`, 
                                this.currentMousePos.x + 5, this.currentMousePos.y - 5);
                }
                
                ctx.restore();
            }

            // Atualizar visibilidade das intera√ß√µes baseada na √°rea atual
            updateInteractionsForArea(currentArea) {
                this.interactionPoints.forEach(point => {
                    // Intera√ß√£o area_up_interaction s√≥ funciona na √°rea "up"
                    if (point.id === 'area_up_interaction') {
                        point.visible = (currentArea === 'up');
                        if (!point.visible) {
                            point.isHovered = false; // Reset hover se n√£o estiver vis√≠vel
                        }
                    }
                });
            }

            // Verificar intera√ß√µes - otimizado por √°rea
            checkInteractions() {
                const currentArea = this.gameClient.areaManager ? this.gameClient.areaManager.getCurrentArea() : 'down';
                
                // Cache do player para evitar m√∫ltiplas buscas (s√≥ se necess√°rio)
                let playerCached = false;
                
                this.interactionPoints.forEach(point => {
                    // OTIMIZA√á√ÉO PRINCIPAL: S√≥ processar intera√ß√µes da √°rea atual
                    if (point.requiredArea && point.requiredArea !== currentArea) {
                        // Reset estado se n√£o estiver na √°rea correta
                        if (point.isHovered) point.isHovered = false;
                        if (point.playerInside) {
                            point.playerInside = false;
                            point.audioPlayed = false; // Reset √°udio ao sair da √°rea
                        }
                        return; // Skip processamento - ECONOMIA MASSIVA DE CPU
                    }

                    // Verifica√ß√£o de cooldown
                    if (point.cooldown > 0) {
                        point.cooldown--;
                    }

                    // Verifica√ß√£o de mouse (sempre ativa)
                    const wasHovered = point.isHovered;
                    point.isHovered = this.isPointInside(this.currentMousePos, point);

                    // Eventos de mouse
                    if (point.isHovered && !wasHovered) {
                        this.onPointEnter(point);
                    }
                    
                    if (!point.isHovered && wasHovered) {
                        this.onPointLeave(point);
                    }

                    // Verifica√ß√£o de personagem (s√≥ para intera√ß√µes espec√≠ficas e na √°rea correta)
                    if (point.id === 'area_up_interaction' && currentArea === 'up') {
                        // Cache player apenas quando necess√°rio
                        if (!playerCached) {
                            if (!this.cachedPlayer || this.playerCacheTime < Date.now() - 100) {
                                this.cachedPlayer = this.findPlayer();
                                this.playerCacheTime = Date.now();
                            }
                            playerCached = true;
                        }
                        
                        if (this.cachedPlayer) {
                            this.checkPlayerInInteractionAreaOptimized(point);
                        }
                    }
                });
            }

            // Buscar player com fallbacks
            findPlayer() {
                let player = this.gameClient.player;
                
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                return player;
            }

            // Vers√£o otimizada da verifica√ß√£o do personagem
            checkPlayerInInteractionAreaOptimized(point) {
                const player = this.cachedPlayer;
                if (!player) return;

                // Throttling: s√≥ verificar a cada 5 frames (~83ms a 60fps)
                point.checkCounter = (point.checkCounter || 0) + 1;
                if (point.checkCounter % 5 !== 0) return;

                const playerPos = {
                    x: player.x,
                    y: player.y
                };

                const wasPlayerInside = point.playerInside || false;
                const isPlayerInside = this.isPointInside(playerPos, point);

                // Personagem entrou na √°rea de intera√ß√£o
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o √°udio j√° foi tocado nesta sess√£o na √°rea
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`üö™ Personagem entrou na √°rea de teleporte! Pos: (${playerPos.x.toFixed(1)}, ${playerPos.y.toFixed(1)})`);
                        
                        // Reproduzir √°udio imediatamente (sem delay)
                        this.playAudioImmediate('songs/tp_song.mp3');
                    } else {
                        console.log('üîá √Åudio j√° foi tocado nesta entrada na √°rea');
                    }
                }
                
                // Personagem saiu da √°rea de intera√ß√£o
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do √°udio ao sair
                    console.log('üö∂ Personagem saiu da √°rea de teleporte - √°udio resetado');
                }
            }

            // Reproduzir √°udio de forma mais eficiente
            playAudioImmediate(audioPath) {
                try {
                    if (window.audioManager) {
                        // Usar m√©todo otimizado para reprodu√ß√£o instant√¢nea
                        audioManager.playAudioFast(audioPath);
                    }
                } catch (error) {
                    console.error('‚ùå Erro ao reproduzir √°udio:', error);
                }
            }

            // Verificar se o personagem est√° dentro da √°rea de intera√ß√£o (m√©todo antigo - mantido para compatibilidade)
            checkPlayerInInteractionArea(point) {
                // Tentar m√∫ltiplas formas de acessar o player
                let player = this.gameClient.player;
                
                // Se n√£o encontrar, tentar pelo gameCore
                if (!player && window.gameCore && window.gameCore.player) {
                    player = window.gameCore.player;
                }
                
                // Se ainda n√£o encontrar, tentar pelo frameBasedGame
                if (!player && this.gameClient.frameBasedGame && this.gameClient.frameBasedGame.player) {
                    player = this.gameClient.frameBasedGame.player;
                }
                
                if (!player) {
                    console.log('üö´ Player n√£o encontrado - verificando √°rea s√≥ com mouse');
                    return;
                }

                const playerPos = {
                    x: player.x,
                    y: player.y
                };

                const wasPlayerInside = point.playerInside || false;
                const isPlayerInside = this.isPointInside(playerPos, point);

                // Personagem entrou na √°rea de intera√ß√£o
                if (isPlayerInside && !wasPlayerInside) {
                    point.playerInside = true;
                    
                    // Verificar se o √°udio j√° foi tocado nesta sess√£o na √°rea
                    if (!point.audioPlayed) {
                        point.audioPlayed = true; // Marcar como tocado
                        console.log(`üö™ Personagem entrou na √°rea de teleporte! Pos: (${playerPos.x.toFixed(1)}, ${playerPos.y.toFixed(1)})`);
                        
                        // Reproduzir √°udio automaticamente (apenas uma vez)
                        if (window.audioManager) {
                            audioManager.playAudio('songs/tp_song.mp3');
                        }
                        
                        console.log('üéµ Tocando tp_song.mp3 - Portal ativado!');
                    } else {
                        console.log('üîá √Åudio j√° foi tocado nesta entrada na √°rea');
                    }
                }
                
                // Personagem saiu da √°rea de intera√ß√£o
                if (!isPlayerInside && wasPlayerInside) {
                    point.playerInside = false;
                    point.audioPlayed = false; // Reset do estado do √°udio ao sair
                    console.log('üö∂ Personagem saiu da √°rea de teleporte - √°udio resetado');
                }
            }
        }

        // Teclas especiais
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                // Toggle debug de colis√µes
                if (window.gameCore) {
                    gameCore.collisionManager.debugMode = !gameCore.collisionManager.debugMode;
                    console.log('üêõ Debug de colis√µes:', gameCore.collisionManager.debugMode);
                }
            }
            
            if (e.key === 'F2') {
                // Toggle debug de intera√ß√µes
                if (window.gameCore) {
                    gameCore.interactionManager.debugMode = !gameCore.interactionManager.debugMode;
                    console.log('üêõ Debug de intera√ß√µes:', gameCore.interactionManager.debugMode);
                }
            }
            
            if (e.key === 'F3') {
                // Reset posi√ß√£o do player
                if (gameClient && gameClient.player) {
                    gameClient.player.x = 400;
                    gameClient.player.y = 300;
                    console.log('üîÑ Posi√ß√£o resetada');
                }
            }
            
            if (e.key === 'F4') {
                // Reconectar ao servidor
                if (gameClient) {
                    console.log('üîÑ Tentando reconectar...');
                    if (gameClient.gameState.isConnected) {
                        gameClient.disconnect();
                        setTimeout(() => {
                            gameClient.connect('Player').catch(err => {
                                console.log('‚ùå Falha na reconex√£o:', err.message);
                            });
                        }, 1000);
                    } else {
                        gameClient.connect('Player').catch(err => {
                            console.log('‚ùå Falha na conex√£o:', err.message);
                        });
                    }
                }
            }
        });

        // Bot√£o de teste de conex√£o
        document.addEventListener('DOMContentLoaded', () => {
            const testButton = document.getElementById('testConnection');
            if (testButton) {
                testButton.addEventListener('click', async () => {
                    console.log('üß™ Iniciando teste de conex√£o...');
                    testButton.textContent = 'üîÑ Testando...';
                    testButton.disabled = true;
                    
                    try {
                        const networkManager = new NetworkManager();
                        await networkManager.connect({
                            name: 'TestPlayer',
                            color: '#00FF00'
                        });
                        
                        console.log('‚úÖ Teste de conex√£o bem-sucedido!');
                        testButton.textContent = '‚úÖ Conectado!';
                        testButton.style.background = '#4CAF50';
                        
                        // Desconectar ap√≥s teste
                        setTimeout(() => {
                            networkManager.disconnect();
                            testButton.textContent = 'üîó Testar Conex√£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                        
                    } catch (error) {
                        console.error('‚ùå Teste de conex√£o falhou:', error);
                        testButton.textContent = '‚ùå Falhou';
                        testButton.style.background = '#f44336';
                        
                        setTimeout(() => {
                            testButton.textContent = 'üîó Testar Conex√£o';
                            testButton.disabled = false;
                            testButton.style.background = '#4CAF50';
                        }, 3000);
                    }
                });
            }
        });

        // Inicializar quando a p√°gina carregar
        window.addEventListener('load', initGame);
    </script>

</body>
</html>